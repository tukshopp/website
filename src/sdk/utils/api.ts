/* tslint:disable */
/* eslint-disable */
/**
 * Miscellaneous Docs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddToWaitListDTO
 */
export interface AddToWaitListDTO {
    /**
     * 
     * @type {string}
     * @memberof AddToWaitListDTO
     */
    'contactName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddToWaitListDTO
     */
    'contactEmail': string;
    /**
     * 
     * @type {string}
     * @memberof AddToWaitListDTO
     */
    'contactPhone'?: string;
    /**
     * tag describing users location
     * @type {string}
     * @memberof AddToWaitListDTO
     */
    'addressTag': string;
}
/**
 * 
 * @export
 * @interface AddressIntentResponse
 */
export interface AddressIntentResponse {
    /**
     * An array of zones near the provided address or coordinates.
     * @type {Array<Zone>}
     * @memberof AddressIntentResponse
     */
    'nearbyZones': Array<Zone>;
    /**
     * The formatted address string.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'address': string;
    /**
     * The state code of the address.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'stateCode': string;
    /**
     * The full name of the state.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'state': string;
    /**
     * The country name.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'country': string;
    /**
     * The two-letter ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'countryCode': string;
    /**
     * 
     * @type {number}
     * @memberof AddressIntentResponse
     */
    'longitude': number;
    /**
     * 
     * @type {number}
     * @memberof AddressIntentResponse
     */
    'latitude': number;
}
/**
 * 
 * @export
 * @interface ConfirmOrderReceivedDTO
 */
export interface ConfirmOrderReceivedDTO {
    /**
     * The unique PIN provided to the customer for order confirmation.
     * @type {string}
     * @memberof ConfirmOrderReceivedDTO
     */
    'orderConfirmationPin': string;
}
/**
 * 
 * @export
 * @interface ContactUsDto
 */
export interface ContactUsDto {
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'comments': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ContactUsDto
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'iso_code': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'default_currency_code': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Country
     */
    'supported_currency_code': Array<string>;
}
/**
 * 
 * @export
 * @interface FileUploadResult
 */
export interface FileUploadResult {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResult
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResult
     */
    'public_id': string;
}
/**
 * 
 * @export
 * @interface GlobalTaxonomy
 */
export interface GlobalTaxonomy {
    /**
     * Unique identifier for the vendor, automatically generated by MongoDB.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'id': string;
    /**
     * Name of the global category or market type.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'name': string;
    /**
     * The kebab-case version of the category name for URL paths.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'handle'?: string;
    /**
     * Optional description providing more details about the category or market type.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'description'?: string;
    /**
     * The ID of the parent category, if this category is a subcategory.
     * @type {object}
     * @memberof GlobalTaxonomy
     */
    'parentCategoryId'?: object;
    /**
     * The type of category (product_category or market_type).
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'categoryType': GlobalTaxonomyCategoryTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof GlobalTaxonomy
     */
    'tags': Array<string>;
    /**
     * URL or path to an image representing the category or market type (e.g., a logo or icon).
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'emojiText'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'coverImageUrl'?: string;
}

export const GlobalTaxonomyCategoryTypeEnum = {
    ProductCategory: 'product-category',
    MarketType: 'market-type'
} as const;

export type GlobalTaxonomyCategoryTypeEnum = typeof GlobalTaxonomyCategoryTypeEnum[keyof typeof GlobalTaxonomyCategoryTypeEnum];

/**
 * 
 * @export
 * @interface MarketTypeDefinition
 */
export interface MarketTypeDefinition {
    /**
     * 
     * @type {string}
     * @memberof MarketTypeDefinition
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MarketTypeDefinition
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof MarketTypeDefinition
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof MarketTypeDefinition
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof MarketTypeDefinition
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof MarketTypeDefinition
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * Unique identifier for the vendor, automatically generated by MongoDB.
     * @type {string}
     * @memberof Review
     */
    'id': string;
    /**
     * Unique identifier for the review account.
     * @type {object}
     * @memberof Review
     */
    'reviewerId': object;
    /**
     * Unique identifier for resource being reviewed.
     * @type {string}
     * @memberof Review
     */
    'resourceId': string;
    /**
     * Review resource type
     * @type {string}
     * @memberof Review
     */
    'resourceType': string;
    /**
     * Review actual review
     * @type {string}
     * @memberof Review
     */
    'body'?: string;
    /**
     * Rating
     * @type {number}
     * @memberof Review
     */
    'rating'?: number;
    /**
     * Timestamp when the vendor document was created.
     * @type {string}
     * @memberof Review
     */
    'createdAt': string;
    /**
     * Timestamp when the vendor document was last updated.
     * @type {string}
     * @memberof Review
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface State
 */
export interface State {
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'country_code': string;
}
/**
 * 
 * @export
 * @interface SubmitFeedbackDto
 */
export interface SubmitFeedbackDto {
    /**
     * Overall rating (1-5 stars)
     * @type {number}
     * @memberof SubmitFeedbackDto
     */
    'rating'?: number;
    /**
     * feedback 
     * @type {string}
     * @memberof SubmitFeedbackDto
     */
    'comments': string;
    /**
     * The ID of the order this feedback is related to (optional)
     * @type {string}
     * @memberof SubmitFeedbackDto
     */
    'orderId'?: string;
    /**
     * The ID of the outlet this feedback is about (optional)
     * @type {string}
     * @memberof SubmitFeedbackDto
     */
    'outletId'?: string;
}
/**
 * 
 * @export
 * @interface TestPushNotificationDto
 */
export interface TestPushNotificationDto {
    /**
     * 
     * @type {string}
     * @memberof TestPushNotificationDto
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TestPushNotificationDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TestPushNotificationDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpsertReviewDTO
 */
export interface UpsertReviewDTO {
    /**
     * Unique identifier for the review account.
     * @type {object}
     * @memberof UpsertReviewDTO
     */
    'reviewerId': object;
    /**
     * Unique identifier for resource being reviewed.
     * @type {string}
     * @memberof UpsertReviewDTO
     */
    'resourceId': string;
    /**
     * Review resource type
     * @type {string}
     * @memberof UpsertReviewDTO
     */
    'resourceType': string;
    /**
     * Review actual review
     * @type {string}
     * @memberof UpsertReviewDTO
     */
    'body'?: string;
    /**
     * Rating
     * @type {number}
     * @memberof UpsertReviewDTO
     */
    'rating'?: number;
}
/**
 * 
 * @export
 * @interface ValidateBankNumberResponse
 */
export interface ValidateBankNumberResponse {
    /**
     * 
     * @type {string}
     * @memberof ValidateBankNumberResponse
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof ValidateBankNumberResponse
     */
    'account_name': string;
    /**
     * 
     * @type {number}
     * @memberof ValidateBankNumberResponse
     */
    'bank_id': number;
}
/**
 * 
 * @export
 * @interface Zone
 */
export interface Zone {
    /**
     * Unique identifier for the zone, automatically generated by MongoDB.
     * @type {object}
     * @memberof Zone
     */
    'id': object;
    /**
     * 
     * @type {ZoneOverviewMeta}
     * @memberof Zone
     */
    'meta'?: ZoneOverviewMeta;
    /**
     * Name of the zone. This should be a human-readable name that clearly identifies the zone, such as \"Rayfield\" or \"GRA\".
     * @type {string}
     * @memberof Zone
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'handle': string;
    /**
     * Zone alias. This is an optional alternative name or short form for the zone, which can be used for display purposes or user convenience.
     * @type {string}
     * @memberof Zone
     */
    'alias'?: string;
    /**
     * Description of the zone. This provides additional context or details about the zone, such as its boundaries, landmarks, or other relevant information.
     * @type {string}
     * @memberof Zone
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Zone
     */
    'areas': Array<string>;
    /**
     * 
     * @type {ZoneConfig}
     * @memberof Zone
     */
    'config': ZoneConfig;
    /**
     * Geographic coordinates (longitude, latitude) of the zone\'s center point. This is used to define the zone\'s location on a map.
     * @type {Array<number>}
     * @memberof Zone
     */
    'coordinates': Array<number>;
    /**
     * Radius of the zone in meters. This defines the circular area around the center point that is considered part of the zone.
     * @type {number}
     * @memberof Zone
     */
    'radius': number;
    /**
     * 
     * @type {ZoneCentralAddress}
     * @memberof Zone
     */
    'address': ZoneCentralAddress;
    /**
     * State or region code within the country where the zone is located. This should be a valid code for the specified country.
     * @type {string}
     * @memberof Zone
     */
    'stateCode': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'averageDeliveryTimeWithinZoneDesc': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'minimumDeliveryFee': string;
    /**
     * 
     * @type {boolean}
     * @memberof Zone
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface ZoneAddressIntentResponse
 */
export interface ZoneAddressIntentResponse {
    /**
     * The formatted address string.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'address': string;
    /**
     * The state code of the address.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'stateCode': string;
    /**
     * The full name of the state.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'state': string;
    /**
     * The country name.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'country': string;
    /**
     * The two-letter ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'countryCode': string;
    /**
     * 
     * @type {number}
     * @memberof ZoneAddressIntentResponse
     */
    'longitude': number;
    /**
     * 
     * @type {number}
     * @memberof ZoneAddressIntentResponse
     */
    'latitude': number;
}
/**
 * 
 * @export
 * @interface ZoneCentralAddress
 */
export interface ZoneCentralAddress {
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'country'?: string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'countryCode'?: string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'state'?: string;
    /**
     * State or region code within the country where the zone is located.
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'stateCode'?: string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'address'?: string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof ZoneCentralAddress
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof ZoneCentralAddress
     */
    'longitude'?: number;
    /**
     * The building number or apartment number of the address.
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'buildingNumber'?: string;
}
/**
 * 
 * @export
 * @interface ZoneConfig
 */
export interface ZoneConfig {
    /**
     * 
     * @type {number}
     * @memberof ZoneConfig
     */
    'averageDeliveryTimeInMins'?: number;
    /**
     * A fixed delivery fee applied to all orders within this zone (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'fixedDeliveryFee': number;
    /**
     * A delivery fee applied per kilometer within this zone (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'flatRatePerKm': number;
    /**
     * Minimum charge for distance-based delivery (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'minDistanceDeliveryFee'?: number;
    /**
     * Preferred delivery fee type to use for this zone. Can be either \"flat_rate\" or \"distance_based\".
     * @type {string}
     * @memberof ZoneConfig
     */
    'deliveryFeeType': ZoneConfigDeliveryFeeTypeEnum;
}

export const ZoneConfigDeliveryFeeTypeEnum = {
    FlatRate: 'flat_rate',
    DistanceBased: 'distance_based',
    Free: 'free'
} as const;

export type ZoneConfigDeliveryFeeTypeEnum = typeof ZoneConfigDeliveryFeeTypeEnum[keyof typeof ZoneConfigDeliveryFeeTypeEnum];

/**
 * 
 * @export
 * @interface ZoneOverviewMeta
 */
export interface ZoneOverviewMeta {
    /**
     * 
     * @type {number}
     * @memberof ZoneOverviewMeta
     */
    'totalOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof ZoneOverviewMeta
     */
    'totalOutlets'?: number;
}

/**
 * BanksApi - axios parameter creator
 * @export
 */
export const BanksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetBanks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/miscellaneous/bank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BanksApi - functional programming interface
 * @export
 */
export const BanksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BanksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetBanks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetBanks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BanksApi.miscellaneousControllerGetBanks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BanksApi - factory interface
 * @export
 */
export const BanksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BanksApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetBanks(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.miscellaneousControllerGetBanks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BanksApi - object-oriented interface
 * @export
 * @class BanksApi
 * @extends {BaseAPI}
 */
export class BanksApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BanksApi
     */
    public miscellaneousControllerGetBanks(options?: RawAxiosRequestConfig) {
        return BanksApiFp(this.configuration).miscellaneousControllerGetBanks(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerFeedbackApi - axios parameter creator
 * @export
 */
export const CustomerFeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Contact us
         * @param {ContactUsDto} contactUsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerFeedbackControllerSubmitContactUs: async (contactUsDto: ContactUsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactUsDto' is not null or undefined
            assertParamExists('customerFeedbackControllerSubmitContactUs', 'contactUsDto', contactUsDto)
            const localVarPath = `/v1/miscellaneous/customer/feedback/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit feedback from a customer
         * @param {SubmitFeedbackDto} submitFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerFeedbackControllerSubmitFeedback: async (submitFeedbackDto: SubmitFeedbackDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitFeedbackDto' is not null or undefined
            assertParamExists('customerFeedbackControllerSubmitFeedback', 'submitFeedbackDto', submitFeedbackDto)
            const localVarPath = `/v1/miscellaneous/customer/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerFeedbackApi - functional programming interface
 * @export
 */
export const CustomerFeedbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerFeedbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Contact us
         * @param {ContactUsDto} contactUsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerFeedbackControllerSubmitContactUs(contactUsDto: ContactUsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerFeedbackControllerSubmitContactUs(contactUsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerFeedbackApi.customerFeedbackControllerSubmitContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Submit feedback from a customer
         * @param {SubmitFeedbackDto} submitFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerFeedbackControllerSubmitFeedback(submitFeedbackDto: SubmitFeedbackDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerFeedbackControllerSubmitFeedback(submitFeedbackDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerFeedbackApi.customerFeedbackControllerSubmitFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerFeedbackApi - factory interface
 * @export
 */
export const CustomerFeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerFeedbackApiFp(configuration)
    return {
        /**
         * 
         * @summary Contact us
         * @param {ContactUsDto} contactUsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerFeedbackControllerSubmitContactUs(contactUsDto: ContactUsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerFeedbackControllerSubmitContactUs(contactUsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit feedback from a customer
         * @param {SubmitFeedbackDto} submitFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerFeedbackControllerSubmitFeedback(submitFeedbackDto: SubmitFeedbackDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerFeedbackControllerSubmitFeedback(submitFeedbackDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerFeedbackApi - object-oriented interface
 * @export
 * @class CustomerFeedbackApi
 * @extends {BaseAPI}
 */
export class CustomerFeedbackApi extends BaseAPI {
    /**
     * 
     * @summary Contact us
     * @param {ContactUsDto} contactUsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerFeedbackApi
     */
    public customerFeedbackControllerSubmitContactUs(contactUsDto: ContactUsDto, options?: RawAxiosRequestConfig) {
        return CustomerFeedbackApiFp(this.configuration).customerFeedbackControllerSubmitContactUs(contactUsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit feedback from a customer
     * @param {SubmitFeedbackDto} submitFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerFeedbackApi
     */
    public customerFeedbackControllerSubmitFeedback(submitFeedbackDto: SubmitFeedbackDto, options?: RawAxiosRequestConfig) {
        return CustomerFeedbackApiFp(this.configuration).customerFeedbackControllerSubmitFeedback(submitFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DataTypesApi - axios parameter creator
 * @export
 */
export const DataTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMarketTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/miscellaneous/market-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMarketTypesMain: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/miscellaneous/global-market-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetProductCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/miscellaneous/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataTypesApi - functional programming interface
 * @export
 */
export const DataTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetMarketTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarketTypeDefinition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetMarketTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataTypesApi.miscellaneousControllerGetMarketTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetMarketTypesMain(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GlobalTaxonomy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetMarketTypesMain(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataTypesApi.miscellaneousControllerGetMarketTypesMain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetProductCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GlobalTaxonomy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetProductCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataTypesApi.miscellaneousControllerGetProductCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataTypesApi - factory interface
 * @export
 */
export const DataTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataTypesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMarketTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<MarketTypeDefinition>> {
            return localVarFp.miscellaneousControllerGetMarketTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetMarketTypesMain(options?: RawAxiosRequestConfig): AxiosPromise<Array<GlobalTaxonomy>> {
            return localVarFp.miscellaneousControllerGetMarketTypesMain(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetProductCategories(options?: RawAxiosRequestConfig): AxiosPromise<Array<GlobalTaxonomy>> {
            return localVarFp.miscellaneousControllerGetProductCategories(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataTypesApi - object-oriented interface
 * @export
 * @class DataTypesApi
 * @extends {BaseAPI}
 */
export class DataTypesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypesApi
     */
    public miscellaneousControllerGetMarketTypes(options?: RawAxiosRequestConfig) {
        return DataTypesApiFp(this.configuration).miscellaneousControllerGetMarketTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypesApi
     */
    public miscellaneousControllerGetMarketTypesMain(options?: RawAxiosRequestConfig) {
        return DataTypesApiFp(this.configuration).miscellaneousControllerGetMarketTypesMain(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypesApi
     */
    public miscellaneousControllerGetProductCategories(options?: RawAxiosRequestConfig) {
        return DataTypesApiFp(this.configuration).miscellaneousControllerGetProductCategories(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DemoApi - axios parameter creator
 * @export
 */
export const DemoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TestPushNotificationDto} testPushNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerDemoPush: async (testPushNotificationDto: TestPushNotificationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testPushNotificationDto' is not null or undefined
            assertParamExists('miscellaneousControllerDemoPush', 'testPushNotificationDto', testPushNotificationDto)
            const localVarPath = `/v1/miscellaneous/test-fcm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testPushNotificationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemoApi - functional programming interface
 * @export
 */
export const DemoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DemoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TestPushNotificationDto} testPushNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerDemoPush(testPushNotificationDto: TestPushNotificationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerDemoPush(testPushNotificationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemoApi.miscellaneousControllerDemoPush']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DemoApi - factory interface
 * @export
 */
export const DemoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DemoApiFp(configuration)
    return {
        /**
         * 
         * @param {TestPushNotificationDto} testPushNotificationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerDemoPush(testPushNotificationDto: TestPushNotificationDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.miscellaneousControllerDemoPush(testPushNotificationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DemoApi - object-oriented interface
 * @export
 * @class DemoApi
 * @extends {BaseAPI}
 */
export class DemoApi extends BaseAPI {
    /**
     * 
     * @param {TestPushNotificationDto} testPushNotificationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public miscellaneousControllerDemoPush(testPushNotificationDto: TestPushNotificationDto, options?: RawAxiosRequestConfig) {
        return DemoApiFp(this.configuration).miscellaneousControllerDemoPush(testPushNotificationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationApi - axios parameter creator
 * @export
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get address intent data by longitude and latitude
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerAddAddressIntentByCoordinates: async (longitude: number, latitude: number, provider: MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('miscellaneousControllerAddAddressIntentByCoordinates', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('miscellaneousControllerAddAddressIntentByCoordinates', 'latitude', latitude)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('miscellaneousControllerAddAddressIntentByCoordinates', 'provider', provider)
            const localVarPath = `/v1/miscellaneous/addresses/add-intent/coordinates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address intent data by place ID
         * @param {string} placeId The place ID from Mapbox or Google
         * @param {MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerAddAddressIntentByPlaceId: async (placeId: string, provider: MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('miscellaneousControllerAddAddressIntentByPlaceId', 'placeId', placeId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('miscellaneousControllerAddAddressIntentByPlaceId', 'provider', provider)
            const localVarPath = `/v1/miscellaneous/addresses/add-address-intent/place-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (placeId !== undefined) {
                localVarQueryParameter['placeId'] = placeId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetCountries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/miscellaneous/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetStates: async (countryCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('miscellaneousControllerGetStates', 'countryCode', countryCode)
            const localVarPath = `/v1/miscellaneous/states`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 * @export
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get address intent data by longitude and latitude
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerAddAddressIntentByCoordinates(longitude: number, latitude: number, provider: MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerAddAddressIntentByCoordinates(longitude, latitude, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.miscellaneousControllerAddAddressIntentByCoordinates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get address intent data by place ID
         * @param {string} placeId The place ID from Mapbox or Google
         * @param {MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerAddAddressIntentByPlaceId(placeId: string, provider: MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerAddAddressIntentByPlaceId(placeId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.miscellaneousControllerAddAddressIntentByPlaceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetCountries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Country>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.miscellaneousControllerGetCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerGetStates(countryCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<State>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerGetStates(countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.miscellaneousControllerGetStates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 * @export
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get address intent data by longitude and latitude
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerAddAddressIntentByCoordinates(longitude: number, latitude: number, provider: MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum, options?: RawAxiosRequestConfig): AxiosPromise<AddressIntentResponse> {
            return localVarFp.miscellaneousControllerAddAddressIntentByCoordinates(longitude, latitude, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address intent data by place ID
         * @param {string} placeId The place ID from Mapbox or Google
         * @param {MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerAddAddressIntentByPlaceId(placeId: string, provider: MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum, options?: RawAxiosRequestConfig): AxiosPromise<AddressIntentResponse> {
            return localVarFp.miscellaneousControllerAddAddressIntentByPlaceId(placeId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetCountries(options?: RawAxiosRequestConfig): AxiosPromise<Array<Country>> {
            return localVarFp.miscellaneousControllerGetCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} countryCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerGetStates(countryCode: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<State>> {
            return localVarFp.miscellaneousControllerGetStates(countryCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 * @export
 * @class LocationApi
 * @extends {BaseAPI}
 */
export class LocationApi extends BaseAPI {
    /**
     * 
     * @summary Get address intent data by longitude and latitude
     * @param {number} longitude 
     * @param {number} latitude 
     * @param {MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public miscellaneousControllerAddAddressIntentByCoordinates(longitude: number, latitude: number, provider: MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).miscellaneousControllerAddAddressIntentByCoordinates(longitude, latitude, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address intent data by place ID
     * @param {string} placeId The place ID from Mapbox or Google
     * @param {MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public miscellaneousControllerAddAddressIntentByPlaceId(placeId: string, provider: MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).miscellaneousControllerAddAddressIntentByPlaceId(placeId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public miscellaneousControllerGetCountries(options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).miscellaneousControllerGetCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} countryCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationApi
     */
    public miscellaneousControllerGetStates(countryCode: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).miscellaneousControllerGetStates(countryCode, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum = {
    Google: 'google',
    Mapbox: 'mapbox'
} as const;
export type MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum = typeof MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum[keyof typeof MiscellaneousControllerAddAddressIntentByCoordinatesProviderEnum];
/**
 * @export
 */
export const MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum = {
    Google: 'google',
    Mapbox: 'mapbox'
} as const;
export type MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum = typeof MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum[keyof typeof MiscellaneousControllerAddAddressIntentByPlaceIdProviderEnum];


/**
 * MarketplaceApi - axios parameter creator
 * @export
 */
export const MarketplaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent: async (placeId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'placeId', placeId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'provider', provider)
            const localVarPath = `/v1/miscellaneous/zone-utils/address-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (placeId !== undefined) {
                localVarQueryParameter['placeId'] = placeId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations: async (longitude: number, latitude: number, radius: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'latitude', latitude)
            // verify required parameter 'radius' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'radius', radius)
            const localVarPath = `/v1/miscellaneous/zone-utils/nearby-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('zoneUtilsControllerGetZoneById', 'id', id)
            const localVarPath = `/v1/miscellaneous/zone-utils/get-zone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketplaceApi - functional programming interface
 * @export
 */
export const MarketplaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketplaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneAddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerAddAddressIntent(placeId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.zoneUtilsControllerAddAddressIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Zone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.zoneUtilsControllerFindNearbyLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerGetZoneById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.zoneUtilsControllerGetZoneById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketplaceApi - factory interface
 * @export
 */
export const MarketplaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketplaceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<ZoneAddressIntentResponse> {
            return localVarFp.zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Zone>> {
            return localVarFp.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Zone> {
            return localVarFp.zoneUtilsControllerGetZoneById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketplaceApi - object-oriented interface
 * @export
 * @class MarketplaceApi
 * @extends {BaseAPI}
 */
export class MarketplaceApi extends BaseAPI {
    /**
     * 
     * @param {string} placeId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} longitude 
     * @param {number} latitude 
     * @param {number} radius 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).zoneUtilsControllerGetZoneById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderHelperApi - axios parameter creator
 * @export
 */
export const OrderHelperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Confirm delivery of an order using a PIN
         * @param {string} orderId ID of the order to confirm delivery for
         * @param {ConfirmOrderReceivedDTO} confirmOrderReceivedDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderHelperControllerConfirmOrderDelivery: async (orderId: string, confirmOrderReceivedDTO: ConfirmOrderReceivedDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderHelperControllerConfirmOrderDelivery', 'orderId', orderId)
            // verify required parameter 'confirmOrderReceivedDTO' is not null or undefined
            assertParamExists('orderHelperControllerConfirmOrderDelivery', 'confirmOrderReceivedDTO', confirmOrderReceivedDTO)
            const localVarPath = `/v1/miscellaneous/order-helper/{orderId}/confirm-delivery`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmOrderReceivedDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderHelperApi - functional programming interface
 * @export
 */
export const OrderHelperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderHelperApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Confirm delivery of an order using a PIN
         * @param {string} orderId ID of the order to confirm delivery for
         * @param {ConfirmOrderReceivedDTO} confirmOrderReceivedDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderHelperControllerConfirmOrderDelivery(orderId: string, confirmOrderReceivedDTO: ConfirmOrderReceivedDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderHelperControllerConfirmOrderDelivery(orderId, confirmOrderReceivedDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderHelperApi.orderHelperControllerConfirmOrderDelivery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderHelperApi - factory interface
 * @export
 */
export const OrderHelperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderHelperApiFp(configuration)
    return {
        /**
         * 
         * @summary Confirm delivery of an order using a PIN
         * @param {string} orderId ID of the order to confirm delivery for
         * @param {ConfirmOrderReceivedDTO} confirmOrderReceivedDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderHelperControllerConfirmOrderDelivery(orderId: string, confirmOrderReceivedDTO: ConfirmOrderReceivedDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderHelperControllerConfirmOrderDelivery(orderId, confirmOrderReceivedDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderHelperApi - object-oriented interface
 * @export
 * @class OrderHelperApi
 * @extends {BaseAPI}
 */
export class OrderHelperApi extends BaseAPI {
    /**
     * 
     * @summary Confirm delivery of an order using a PIN
     * @param {string} orderId ID of the order to confirm delivery for
     * @param {ConfirmOrderReceivedDTO} confirmOrderReceivedDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderHelperApi
     */
    public orderHelperControllerConfirmOrderDelivery(orderId: string, confirmOrderReceivedDTO: ConfirmOrderReceivedDTO, options?: RawAxiosRequestConfig) {
        return OrderHelperApiFp(this.configuration).orderHelperControllerConfirmOrderDelivery(orderId, confirmOrderReceivedDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewApi - axios parameter creator
 * @export
 */
export const ReviewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewControllerGetResourceReview: async (resourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('reviewControllerGetResourceReview', 'resourceId', resourceId)
            const localVarPath = `/v1/miscellaneous/review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewControllerGetVendorCredentials: async (reviewId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('reviewControllerGetVendorCredentials', 'reviewId', reviewId)
            const localVarPath = `/v1/miscellaneous/review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (reviewId !== undefined) {
                localVarQueryParameter['reviewId'] = reviewId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpsertReviewDTO} upsertReviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewControllerUpsertReview: async (upsertReviewDTO: UpsertReviewDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertReviewDTO' is not null or undefined
            assertParamExists('reviewControllerUpsertReview', 'upsertReviewDTO', upsertReviewDTO)
            const localVarPath = `/v1/miscellaneous/review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertReviewDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewApi - functional programming interface
 * @export
 */
export const ReviewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewControllerGetResourceReview(resourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewControllerGetResourceReview(resourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewApi.reviewControllerGetResourceReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewControllerGetVendorCredentials(reviewId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewControllerGetVendorCredentials(reviewId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewApi.reviewControllerGetVendorCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpsertReviewDTO} upsertReviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewControllerUpsertReview(upsertReviewDTO: UpsertReviewDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewControllerUpsertReview(upsertReviewDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewApi.reviewControllerUpsertReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReviewApi - factory interface
 * @export
 */
export const ReviewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewApiFp(configuration)
    return {
        /**
         * 
         * @param {string} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewControllerGetResourceReview(resourceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Review> {
            return localVarFp.reviewControllerGetResourceReview(resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewControllerGetVendorCredentials(reviewId: string, options?: RawAxiosRequestConfig): AxiosPromise<Review> {
            return localVarFp.reviewControllerGetVendorCredentials(reviewId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpsertReviewDTO} upsertReviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewControllerUpsertReview(upsertReviewDTO: UpsertReviewDTO, options?: RawAxiosRequestConfig): AxiosPromise<Review> {
            return localVarFp.reviewControllerUpsertReview(upsertReviewDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewApi - object-oriented interface
 * @export
 * @class ReviewApi
 * @extends {BaseAPI}
 */
export class ReviewApi extends BaseAPI {
    /**
     * 
     * @param {string} resourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public reviewControllerGetResourceReview(resourceId: string, options?: RawAxiosRequestConfig) {
        return ReviewApiFp(this.configuration).reviewControllerGetResourceReview(resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} reviewId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public reviewControllerGetVendorCredentials(reviewId: string, options?: RawAxiosRequestConfig) {
        return ReviewApiFp(this.configuration).reviewControllerGetVendorCredentials(reviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpsertReviewDTO} upsertReviewDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewApi
     */
    public reviewControllerUpsertReview(upsertReviewDTO: UpsertReviewDTO, options?: RawAxiosRequestConfig) {
        return ReviewApiFp(this.configuration).reviewControllerUpsertReview(upsertReviewDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file without transformations
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadFile: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/miscellaneous/upload/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadImage: async (type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/miscellaneous/upload/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file without transformations
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadControllerUploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.imageUploadControllerUploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadControllerUploadImage(type, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.imageUploadControllerUploadImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file without transformations
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResult> {
            return localVarFp.imageUploadControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResult> {
            return localVarFp.imageUploadControllerUploadImage(type, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file without transformations
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).imageUploadControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload an image with optional resizing
     * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).imageUploadControllerUploadImage(type, file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ImageUploadControllerUploadImageTypeEnum = {
    Thumbnail: 'thumbnail',
    Logo: 'logo',
    ProductImage: 'product-image',
    CoverImage: 'cover-image',
    Medium: 'medium',
    Large: 'large'
} as const;
export type ImageUploadControllerUploadImageTypeEnum = typeof ImageUploadControllerUploadImageTypeEnum[keyof typeof ImageUploadControllerUploadImageTypeEnum];


/**
 * ValidationApi - axios parameter creator
 * @export
 */
export const ValidationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} accountNumber 
         * @param {string} bankCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerValidateAccountNumberPaystack: async (accountNumber: string, bankCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountNumber' is not null or undefined
            assertParamExists('miscellaneousControllerValidateAccountNumberPaystack', 'accountNumber', accountNumber)
            // verify required parameter 'bankCode' is not null or undefined
            assertParamExists('miscellaneousControllerValidateAccountNumberPaystack', 'bankCode', bankCode)
            const localVarPath = `/v1/miscellaneous/validate-account/paystack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountNumber !== undefined) {
                localVarQueryParameter['accountNumber'] = accountNumber;
            }

            if (bankCode !== undefined) {
                localVarQueryParameter['bankCode'] = bankCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidationApi - functional programming interface
 * @export
 */
export const ValidationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} accountNumber 
         * @param {string} bankCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerValidateAccountNumberPaystack(accountNumber: string, bankCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateBankNumberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerValidateAccountNumberPaystack(accountNumber, bankCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValidationApi.miscellaneousControllerValidateAccountNumberPaystack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ValidationApi - factory interface
 * @export
 */
export const ValidationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} accountNumber 
         * @param {string} bankCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerValidateAccountNumberPaystack(accountNumber: string, bankCode: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidateBankNumberResponse> {
            return localVarFp.miscellaneousControllerValidateAccountNumberPaystack(accountNumber, bankCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidationApi - object-oriented interface
 * @export
 * @class ValidationApi
 * @extends {BaseAPI}
 */
export class ValidationApi extends BaseAPI {
    /**
     * 
     * @param {string} accountNumber 
     * @param {string} bankCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationApi
     */
    public miscellaneousControllerValidateAccountNumberPaystack(accountNumber: string, bankCode: string, options?: RawAxiosRequestConfig) {
        return ValidationApiFp(this.configuration).miscellaneousControllerValidateAccountNumberPaystack(accountNumber, bankCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WaitlistApi - axios parameter creator
 * @export
 */
export const WaitlistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddToWaitListDTO} addToWaitListDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerAddToWaitList: async (addToWaitListDTO: AddToWaitListDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addToWaitListDTO' is not null or undefined
            assertParamExists('miscellaneousControllerAddToWaitList', 'addToWaitListDTO', addToWaitListDTO)
            const localVarPath = `/v1/miscellaneous/waitlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addToWaitListDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WaitlistApi - functional programming interface
 * @export
 */
export const WaitlistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WaitlistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddToWaitListDTO} addToWaitListDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miscellaneousControllerAddToWaitList(addToWaitListDTO: AddToWaitListDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miscellaneousControllerAddToWaitList(addToWaitListDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WaitlistApi.miscellaneousControllerAddToWaitList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WaitlistApi - factory interface
 * @export
 */
export const WaitlistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WaitlistApiFp(configuration)
    return {
        /**
         * 
         * @param {AddToWaitListDTO} addToWaitListDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miscellaneousControllerAddToWaitList(addToWaitListDTO: AddToWaitListDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.miscellaneousControllerAddToWaitList(addToWaitListDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WaitlistApi - object-oriented interface
 * @export
 * @class WaitlistApi
 * @extends {BaseAPI}
 */
export class WaitlistApi extends BaseAPI {
    /**
     * 
     * @param {AddToWaitListDTO} addToWaitListDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitlistApi
     */
    public miscellaneousControllerAddToWaitList(addToWaitListDTO: AddToWaitListDTO, options?: RawAxiosRequestConfig) {
        return WaitlistApiFp(this.configuration).miscellaneousControllerAddToWaitList(addToWaitListDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ZoneHelpersApi - axios parameter creator
 * @export
 */
export const ZoneHelpersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent: async (placeId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'placeId', placeId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'provider', provider)
            const localVarPath = `/v1/miscellaneous/zone-utils/address-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (placeId !== undefined) {
                localVarQueryParameter['placeId'] = placeId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations: async (longitude: number, latitude: number, radius: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'latitude', latitude)
            // verify required parameter 'radius' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'radius', radius)
            const localVarPath = `/v1/miscellaneous/zone-utils/nearby-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('zoneUtilsControllerGetZoneById', 'id', id)
            const localVarPath = `/v1/miscellaneous/zone-utils/get-zone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneHelpersApi - functional programming interface
 * @export
 */
export const ZoneHelpersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ZoneHelpersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneAddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerAddAddressIntent(placeId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneHelpersApi.zoneUtilsControllerAddAddressIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Zone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneHelpersApi.zoneUtilsControllerFindNearbyLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerGetZoneById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneHelpersApi.zoneUtilsControllerGetZoneById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ZoneHelpersApi - factory interface
 * @export
 */
export const ZoneHelpersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ZoneHelpersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<ZoneAddressIntentResponse> {
            return localVarFp.zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Zone>> {
            return localVarFp.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Zone> {
            return localVarFp.zoneUtilsControllerGetZoneById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneHelpersApi - object-oriented interface
 * @export
 * @class ZoneHelpersApi
 * @extends {BaseAPI}
 */
export class ZoneHelpersApi extends BaseAPI {
    /**
     * 
     * @param {string} placeId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneHelpersApi
     */
    public zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig) {
        return ZoneHelpersApiFp(this.configuration).zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} longitude 
     * @param {number} latitude 
     * @param {number} radius 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneHelpersApi
     */
    public zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig) {
        return ZoneHelpersApiFp(this.configuration).zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneHelpersApi
     */
    public zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig) {
        return ZoneHelpersApiFp(this.configuration).zoneUtilsControllerGetZoneById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



