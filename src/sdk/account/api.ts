/* tslint:disable */
/* eslint-disable */
/**
 * Account Service API Docs
 * Account Service API endpoints...
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Unique identifier for the account
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * Email address of the account holder
     * @type {string}
     * @memberof Account
     */
    'email': string;
    /**
     * Phone number of the account holder
     * @type {string}
     * @memberof Account
     */
    'phone': string;
    /**
     * First name of the account holder
     * @type {string}
     * @memberof Account
     */
    'firstName'?: string;
    /**
     * Type of account (Individual or Business)
     * @type {string}
     * @memberof Account
     */
    'accountType'?: AccountAccountTypeEnum;
    /**
     * Last name of the account holder
     * @type {string}
     * @memberof Account
     */
    'lastName'?: string;
    /**
     * Unique referral code for this account
     * @type {string}
     * @memberof Account
     */
    'referralCode'?: string;
    /**
     * Referral code of the user who referred this account
     * @type {string}
     * @memberof Account
     */
    'referredBy'?: string;
    /**
     * Current status of the account
     * @type {string}
     * @memberof Account
     */
    'accountStatus'?: AccountAccountStatusEnum;
    /**
     * URL to the user\'s profile photo
     * @type {string}
     * @memberof Account
     */
    'profilePhoto'?: string;
    /**
     * User\'s biographical information
     * @type {string}
     * @memberof Account
     */
    'bio'?: string;
    /**
     * Firebase Cloud Messaging token for push notifications
     * @type {string}
     * @memberof Account
     */
    'fcmToken'?: string;
    /**
     * Reward points accumulated by the user
     * @type {number}
     * @memberof Account
     */
    'points'?: number;
    /**
     * Temporary access token for authentication
     * @type {string}
     * @memberof Account
     */
    'temporalAccessToken'?: string;
    /**
     * One-time password for verification
     * @type {string}
     * @memberof Account
     */
    'otp'?: string;
    /**
     * Expiration timestamp for the OTP
     * @type {string}
     * @memberof Account
     */
    'otpExpires'?: string;
    /**
     * Expiration date for email activation token
     * @type {string}
     * @memberof Account
     */
    'emailActivationExpires'?: string;
    /**
     * Whether the email has been verified
     * @type {boolean}
     * @memberof Account
     */
    'emailActivated'?: boolean;
    /**
     * Customer stats
     * @type {CustomerStats}
     * @memberof Account
     */
    'customerStats'?: CustomerStats;
    /**
     * Connected payout profile for receiving payments
     * @type {PayoutProfile}
     * @memberof Account
     */
    'connectedPayoutProfile'?: PayoutProfile;
    /**
     * Whether the phone number has been verified
     * @type {boolean}
     * @memberof Account
     */
    'phoneActivated'?: boolean;
    /**
     * Most recent Paystack customer event
     * @type {string}
     * @memberof Account
     */
    'paystackCustomerMostRecentEvent'?: string;
    /**
     * Paystack DVA account number
     * @type {string}
     * @memberof Account
     */
    'paystackCustomerDVAAccountNumber'?: string;
    /**
     * Paystack customer code
     * @type {string}
     * @memberof Account
     */
    'paystackCustomerCode'?: string;
    /**
     * Paystack customer ID
     * @type {string}
     * @memberof Account
     */
    'paystackCustomerId'?: string;
    /**
     * Paystack Dedicated Virtual Account details
     * @type {PaystackDVA}
     * @memberof Account
     */
    'paystackDVA'?: PaystackDVA;
    /**
     * Array of saved payment cards
     * @type {Array<Card>}
     * @memberof Account
     */
    'savedCards'?: Array<Card>;
    /**
     * Array of delivery addresses
     * @type {Array<CustomerAddress>}
     * @memberof Account
     */
    'addresses'?: Array<CustomerAddress>;
    /**
     * Current location address of the customer
     * @type {CustomerAddress}
     * @memberof Account
     */
    'myLocation'?: CustomerAddress;
    /**
     * Whether location tracking is enabled
     * @type {boolean}
     * @memberof Account
     */
    'myLocationEnabled'?: boolean;
    /**
     * Whether the account requires attention
     * @type {boolean}
     * @memberof Account
     */
    'requiresAttention'?: boolean;
    /**
     * Timestamp of last login
     * @type {string}
     * @memberof Account
     */
    'lastLogin'?: string;
    /**
     * ID of the zone this account belongs to
     * @type {string}
     * @memberof Account
     */
    'zoneId'?: string;
    /**
     * Timestamp when the account was created
     * @type {string}
     * @memberof Account
     */
    'createdAt'?: string;
    /**
     * Timestamp when the account was last updated
     * @type {string}
     * @memberof Account
     */
    'updatedAt'?: string;
}

export const AccountAccountTypeEnum = {
    Vendor: 'vendor',
    Individual: 'individual',
    Rider: 'rider',
    Admin: 'admin',
    SuperAdmin: 'super-admin',
    System: 'system'
} as const;

export type AccountAccountTypeEnum = typeof AccountAccountTypeEnum[keyof typeof AccountAccountTypeEnum];
export const AccountAccountStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Inactive: 'inactive',
    ShadowBanned: 'shadow_banned',
    Disabled: 'disabled'
} as const;

export type AccountAccountStatusEnum = typeof AccountAccountStatusEnum[keyof typeof AccountAccountStatusEnum];

/**
 * 
 * @export
 * @interface AccountPublicDto
 */
export interface AccountPublicDto {
    /**
     * Type of account (Individual or Business)
     * @type {string}
     * @memberof AccountPublicDto
     */
    'accountType'?: AccountPublicDtoAccountTypeEnum;
    /**
     * Current status of the account
     * @type {string}
     * @memberof AccountPublicDto
     */
    'accountStatus'?: AccountPublicDtoAccountStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'emailActivated'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'profilePhoto'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'phoneActivated'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPublicDto
     */
    'updatedAt'?: string;
}

export const AccountPublicDtoAccountTypeEnum = {
    Vendor: 'vendor',
    Individual: 'individual',
    Rider: 'rider',
    Admin: 'admin',
    SuperAdmin: 'super-admin',
    System: 'system'
} as const;

export type AccountPublicDtoAccountTypeEnum = typeof AccountPublicDtoAccountTypeEnum[keyof typeof AccountPublicDtoAccountTypeEnum];
export const AccountPublicDtoAccountStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Inactive: 'inactive',
    ShadowBanned: 'shadow_banned',
    Disabled: 'disabled'
} as const;

export type AccountPublicDtoAccountStatusEnum = typeof AccountPublicDtoAccountStatusEnum[keyof typeof AccountPublicDtoAccountStatusEnum];

/**
 * 
 * @export
 * @interface ActivateWalletDTO
 */
export interface ActivateWalletDTO {
    /**
     * The unique identifier of the wallet to be activated.
     * @type {string}
     * @memberof ActivateWalletDTO
     */
    'walletId': string;
}
/**
 * 
 * @export
 * @interface AddListItemDTO
 */
export interface AddListItemDTO {
    /**
     * The type of list item (e.g., \"favorite\", \"like\", \"viewed\").
     * @type {string}
     * @memberof AddListItemDTO
     */
    'type': AddListItemDTOTypeEnum;
    /**
     * Image url
     * @type {string}
     * @memberof AddListItemDTO
     */
    'imageUrl': string;
    /**
     * Entity title
     * @type {string}
     * @memberof AddListItemDTO
     */
    'title': string;
    /**
     * The ID of the entity this list item references (e.g., a product or outlet ID).
     * @type {string}
     * @memberof AddListItemDTO
     */
    'entityId': string;
    /**
     * The type of entity this list item references (e.g., \"Product\", \"Outlet\").
     * @type {string}
     * @memberof AddListItemDTO
     */
    'entityType': AddListItemDTOEntityTypeEnum;
}

export const AddListItemDTOTypeEnum = {
    Favorite: 'favorite',
    Like: 'like',
    Viewed: 'viewed',
    Wishlist: 'wishlist',
    SearchHistoryEntry: 'search-history-entry'
} as const;

export type AddListItemDTOTypeEnum = typeof AddListItemDTOTypeEnum[keyof typeof AddListItemDTOTypeEnum];
export const AddListItemDTOEntityTypeEnum = {
    Product: 'product',
    Outlet: 'outlet',
    PlaceSearch: 'place-search'
} as const;

export type AddListItemDTOEntityTypeEnum = typeof AddListItemDTOEntityTypeEnum[keyof typeof AddListItemDTOEntityTypeEnum];

/**
 * 
 * @export
 * @interface AddressIntentResponse
 */
export interface AddressIntentResponse {
    /**
     * An array of zones near the provided address or coordinates.
     * @type {Array<Zone>}
     * @memberof AddressIntentResponse
     */
    'nearbyZones': Array<Zone>;
    /**
     * The formatted address string.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'address': string;
    /**
     * The state code of the address.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'stateCode': string;
    /**
     * The full name of the state.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'state': string;
    /**
     * The country name.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'country': string;
    /**
     * The two-letter ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof AddressIntentResponse
     */
    'countryCode': string;
    /**
     * 
     * @type {number}
     * @memberof AddressIntentResponse
     */
    'longitude': number;
    /**
     * 
     * @type {number}
     * @memberof AddressIntentResponse
     */
    'latitude': number;
}
/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * The name of the cardholder as it appears on the card.
     * @type {string}
     * @memberof Card
     */
    'name'?: string;
    /**
     * Unique ID
     * @type {string}
     * @memberof Card
     */
    'id': string;
    /**
     * The card brand or network.
     * @type {string}
     * @memberof Card
     */
    'brand': CardBrandEnum;
    /**
     * The two-letter ISO 3166-1 alpha-2 country code of the card\'s issuing country.
     * @type {string}
     * @memberof Card
     */
    'countryCode': string;
    /**
     * The four-digit year of the card\'s expiration date.
     * @type {string}
     * @memberof Card
     */
    'expYear': string;
    /**
     * The two-digit month of the card\'s expiration date (1-12).
     * @type {string}
     * @memberof Card
     */
    'expMonth': string;
    /**
     * The last four digits of the card number.
     * @type {string}
     * @memberof Card
     */
    'last4': string;
    /**
     * The authorization code received from the payment gateway after successful authorization.
     * @type {string}
     * @memberof Card
     */
    'authorizationCode': string;
    /**
     * The name of the payment provider or gateway used to process transactions with this card.
     * @type {string}
     * @memberof Card
     */
    'provider': CardProviderEnum;
}

export const CardBrandEnum = {
    Visa: 'visa',
    Mastercard: 'mastercard',
    Verve: 'verve'
} as const;

export type CardBrandEnum = typeof CardBrandEnum[keyof typeof CardBrandEnum];
export const CardProviderEnum = {
    Paystack: 'paystack',
    Flutterwave: 'flutterwave'
} as const;

export type CardProviderEnum = typeof CardProviderEnum[keyof typeof CardProviderEnum];

/**
 * 
 * @export
 * @interface CustomerAddress
 */
export interface CustomerAddress {
    /**
     * 
     * @type {string}
     * @memberof CustomerAddress
     */
    'id'?: string;
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof CustomerAddress
     */
    'country'?: string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof CustomerAddress
     */
    'countryCode'?: string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof CustomerAddress
     */
    'state'?: string;
    /**
     * State or region code within the country where the zone is located.
     * @type {string}
     * @memberof CustomerAddress
     */
    'stateCode'?: string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof CustomerAddress
     */
    'address'?: string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof CustomerAddress
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof CustomerAddress
     */
    'longitude'?: number;
    /**
     * Additional notes or instructions for the address
     * @type {string}
     * @memberof CustomerAddress
     */
    'notes'?: string;
    /**
     * The type or category of the address.
     * @type {string}
     * @memberof CustomerAddress
     */
    'type'?: CustomerAddressTypeEnum;
    /**
     * A nearby landmark or easily recognizable location near the address.
     * @type {string}
     * @memberof CustomerAddress
     */
    'landmark'?: string;
    /**
     * The ID of the zone in which this address is located.
     * @type {string}
     * @memberof CustomerAddress
     */
    'zoneId'?: string;
    /**
     * The building number or apartment number of the address.
     * @type {string}
     * @memberof CustomerAddress
     */
    'buildingNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerAddress
     */
    'isActive'?: boolean;
}

export const CustomerAddressTypeEnum = {
    Home: 'home',
    Office: 'office',
    School: 'school',
    Other: 'other'
} as const;

export type CustomerAddressTypeEnum = typeof CustomerAddressTypeEnum[keyof typeof CustomerAddressTypeEnum];

/**
 * 
 * @export
 * @interface CustomerStats
 */
export interface CustomerStats {
    /**
     * 
     * @type {number}
     * @memberof CustomerStats
     */
    'totalOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerStats
     */
    'totalCancelledOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerStats
     */
    'totalCompletedOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerStats
     */
    'totalRefundedOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerStats
     */
    'totalRefundedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerStats
     */
    'totalRevenue'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerStats
     */
    'lastOrderDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerStats
     */
    'lastCancelledOrderDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerStats
     */
    'lastCompletedOrderDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerStats
     */
    'lastRefundedOrderDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerStats
     */
    'totalSpent'?: number;
}
/**
 * 
 * @export
 * @interface DeactivateWalletDTO
 */
export interface DeactivateWalletDTO {
    /**
     * The unique identifier of the wallet to be deactivated.
     * @type {string}
     * @memberof DeactivateWalletDTO
     */
    'walletId': string;
    /**
     * The reason for deactivating the wallet.
     * @type {string}
     * @memberof DeactivateWalletDTO
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface DeleteAccountDTO
 */
export interface DeleteAccountDTO {
    /**
     * 
     * @type {string}
     * @memberof DeleteAccountDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface FileUploadResult
 */
export interface FileUploadResult {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResult
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResult
     */
    'public_id': string;
}
/**
 * 
 * @export
 * @interface FundWalletIntentPayWithCard
 */
export interface FundWalletIntentPayWithCard {
    /**
     * The unique identifier of the sender\'s wallet.
     * @type {string}
     * @memberof FundWalletIntentPayWithCard
     */
    'walletId': string;
    /**
     * The amount to fund
     * @type {number}
     * @memberof FundWalletIntentPayWithCard
     */
    'amount': number;
    /**
     * Authorization code
     * @type {string}
     * @memberof FundWalletIntentPayWithCard
     */
    'authorizationCode': string;
}
/**
 * 
 * @export
 * @interface FundWalletIntentPayWithPaystack
 */
export interface FundWalletIntentPayWithPaystack {
    /**
     * The unique identifier of the sender\'s wallet.
     * @type {string}
     * @memberof FundWalletIntentPayWithPaystack
     */
    'walletId': string;
    /**
     * The amount to fund
     * @type {number}
     * @memberof FundWalletIntentPayWithPaystack
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface PayoutProfile
 */
export interface PayoutProfile {
    /**
     * 
     * @type {string}
     * @memberof PayoutProfile
     */
    'accountNumber': string;
    /**
     * 
     * @type {string}
     * @memberof PayoutProfile
     */
    'accountName': string;
    /**
     * 
     * @type {string}
     * @memberof PayoutProfile
     */
    'bankName': string;
    /**
     * 
     * @type {string}
     * @memberof PayoutProfile
     */
    'bankCode': string;
}
/**
 * 
 * @export
 * @interface PaystackDVA
 */
export interface PaystackDVA {
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'accountName': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaystackDVA
     */
    'isActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'bankName': string;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackTitanAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackTitanAccountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackTitanBankName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaystackDVA
     */
    'paystackTitanIsActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackWemaAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackWemaAccountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackWemaBankName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaystackDVA
     */
    'paystackWemaIsActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackTestBankAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackTestBankAccountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaystackDVA
     */
    'paystackTestBankName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaystackDVA
     */
    'paystackTestBankIsActive'?: boolean;
}
/**
 * 
 * @export
 * @interface PriceIncreaseTimeSlot
 */
export interface PriceIncreaseTimeSlot {
    /**
     * Start hour of the price increase time slot (0-23)
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'startHour': number;
    /**
     * End hour of the price increase time slot (0-23)
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'endHour': number;
    /**
     * Type of price increase to apply
     * @type {string}
     * @memberof PriceIncreaseTimeSlot
     */
    'increaseType': PriceIncreaseTimeSlotIncreaseTypeEnum;
    /**
     * Percentage increase to apply during this time slot
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'percentageIncrease'?: number;
    /**
     * Fixed amount (in Naira) to add to the delivery fee during this time slot
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'fixedFeeIncrease'?: number;
}

export const PriceIncreaseTimeSlotIncreaseTypeEnum = {
    Percentage: 'percentage',
    FixedAmount: 'fixed_amount'
} as const;

export type PriceIncreaseTimeSlotIncreaseTypeEnum = typeof PriceIncreaseTimeSlotIncreaseTypeEnum[keyof typeof PriceIncreaseTimeSlotIncreaseTypeEnum];

/**
 * 
 * @export
 * @interface Referral
 */
export interface Referral {
    /**
     * The unique identifier for the referral
     * @type {string}
     * @memberof Referral
     */
    'id': string;
    /**
     * ID of the user who created the referral (referrer)
     * @type {string}
     * @memberof Referral
     */
    'referrerId': string;
    /**
     * Unique ID of the user who was referred
     * @type {string}
     * @memberof Referral
     */
    'referredId': string;
    /**
     * Full name of the referred user
     * @type {string}
     * @memberof Referral
     */
    'fullName': string;
    /**
     * Email address of the referred user
     * @type {string}
     * @memberof Referral
     */
    'email': string;
    /**
     * Timestamp when the referral was created
     * @type {string}
     * @memberof Referral
     */
    'createdAt'?: string;
    /**
     * Timestamp when the referral was last updated
     * @type {string}
     * @memberof Referral
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface TransferBetweenWalletsDTO
 */
export interface TransferBetweenWalletsDTO {
    /**
     * The unique identifier of the sender\'s wallet.
     * @type {string}
     * @memberof TransferBetweenWalletsDTO
     */
    'senderWalletId': string;
    /**
     * The unique identifier of the receiver\'s wallet.
     * @type {string}
     * @memberof TransferBetweenWalletsDTO
     */
    'receiverWalletId': string;
    /**
     * The amount to be transferred.
     * @type {number}
     * @memberof TransferBetweenWalletsDTO
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface TransferToUserWalletDTO
 */
export interface TransferToUserWalletDTO {
    /**
     * The unique identifier of the receiver\'s account id
     * @type {string}
     * @memberof TransferToUserWalletDTO
     */
    'accountId': string;
    /**
     * The amount to be transferred.
     * @type {number}
     * @memberof TransferToUserWalletDTO
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface UpdateAccountDTO
 */
export interface UpdateAccountDTO {
    /**
     * First name of the account holder
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'firstName'?: string;
    /**
     * Last name of the account holder
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'lastName'?: string;
    /**
     * URL to the user\'s profile photo
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'profilePhoto'?: string;
    /**
     * User\'s biographical information
     * @type {string}
     * @memberof UpdateAccountDTO
     */
    'bio'?: string;
    /**
     * Whether location tracking is enabled
     * @type {boolean}
     * @memberof UpdateAccountDTO
     */
    'myLocationEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateAccountEmailDTO
 */
export interface UpdateAccountEmailDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountEmailDTO
     */
    'newEmail': string;
}
/**
 * 
 * @export
 * @interface UpdateAccountPasswordDTO
 */
export interface UpdateAccountPasswordDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountPasswordDTO
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountPasswordDTO
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface UpdateAccountPhoneDTO
 */
export interface UpdateAccountPhoneDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountPhoneDTO
     */
    'newPhone': string;
}
/**
 * 
 * @export
 * @interface UpdateConnectedPayoutProfileDTO
 */
export interface UpdateConnectedPayoutProfileDTO {
    /**
     * Connected payout profile for receiving payments
     * @type {PayoutProfile}
     * @memberof UpdateConnectedPayoutProfileDTO
     */
    'connectedPayoutProfile'?: PayoutProfile;
}
/**
 * 
 * @export
 * @interface UpdateCustomerAddress
 */
export interface UpdateCustomerAddress {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'id'?: string;
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'country'?: string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'countryCode'?: string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'state'?: string;
    /**
     * State or region code within the country where the zone is located.
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'stateCode'?: string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'address'?: string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof UpdateCustomerAddress
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof UpdateCustomerAddress
     */
    'longitude'?: number;
    /**
     * Additional notes or instructions for the address
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'notes'?: string;
    /**
     * The type or category of the address.
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'type'?: UpdateCustomerAddressTypeEnum;
    /**
     * A nearby landmark or easily recognizable location near the address.
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'landmark'?: string;
    /**
     * The building number or apartment number of the address.
     * @type {string}
     * @memberof UpdateCustomerAddress
     */
    'buildingNumber'?: string;
}

export const UpdateCustomerAddressTypeEnum = {
    Home: 'home',
    Office: 'office',
    School: 'school',
    Other: 'other'
} as const;

export type UpdateCustomerAddressTypeEnum = typeof UpdateCustomerAddressTypeEnum[keyof typeof UpdateCustomerAddressTypeEnum];

/**
 * 
 * @export
 * @interface UpdateFCMTokenDTO
 */
export interface UpdateFCMTokenDTO {
    /**
     * Firebase Cloud Messaging token for push notifications
     * @type {string}
     * @memberof UpdateFCMTokenDTO
     */
    'fcmToken'?: string;
}
/**
 * 
 * @export
 * @interface UseMyAddressAddressDTO
 */
export interface UseMyAddressAddressDTO {
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof UseMyAddressAddressDTO
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof UseMyAddressAddressDTO
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface VerifyNewAccountEmailDTO
 */
export interface VerifyNewAccountEmailDTO {
    /**
     * 
     * @type {string}
     * @memberof VerifyNewAccountEmailDTO
     */
    'otp': string;
}
/**
 * 
 * @export
 * @interface VerifyNewAccountPhoneDTO
 */
export interface VerifyNewAccountPhoneDTO {
    /**
     * 
     * @type {string}
     * @memberof VerifyNewAccountPhoneDTO
     */
    'otp': string;
}
/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * Unique identifier for the vendor, automatically generated by MongoDB.
     * @type {string}
     * @memberof Wallet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    'walletClass': WalletWalletClassEnum;
    /**
     * Unique identifier for the vendor account.
     * @type {string}
     * @memberof Wallet
     */
    'ownerId': string;
    /**
     * Current balance in the wallet.
     * @type {number}
     * @memberof Wallet
     */
    'balance': number;
    /**
     * Current ledger balance in the wallet.
     * @type {number}
     * @memberof Wallet
     */
    'ledger_balance': number;
    /**
     * The currency code for the wallet balance (e.g.NGN).
     * @type {string}
     * @memberof Wallet
     */
    'currency'?: WalletCurrencyEnum;
    /**
     * Status of the wallet (e.g., active, inactive, frozen).
     * @type {string}
     * @memberof Wallet
     */
    'status': WalletStatusEnum;
    /**
     * Timestamp when the vendor document was created.
     * @type {string}
     * @memberof Wallet
     */
    'createdAt'?: string;
    /**
     * Timestamp when the vendor document was last updated.
     * @type {string}
     * @memberof Wallet
     */
    'updatedAt'?: string;
}

export const WalletWalletClassEnum = {
    Individual: 'individual',
    Business: 'business'
} as const;

export type WalletWalletClassEnum = typeof WalletWalletClassEnum[keyof typeof WalletWalletClassEnum];
export const WalletCurrencyEnum = {
    Ngn: 'ngn'
} as const;

export type WalletCurrencyEnum = typeof WalletCurrencyEnum[keyof typeof WalletCurrencyEnum];
export const WalletStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Frozen: 'frozen'
} as const;

export type WalletStatusEnum = typeof WalletStatusEnum[keyof typeof WalletStatusEnum];

/**
 * 
 * @export
 * @interface WalletTransaction
 */
export interface WalletTransaction {
    /**
     * Unique identifier for the outlet, automatically generated by MongoDB.
     * @type {string}
     * @memberof WalletTransaction
     */
    'id': string;
    /**
     * Unique identifier for the wallet associated with this transaction.
     * @type {string}
     * @memberof WalletTransaction
     */
    'walletId': string;
    /**
     * The amount involved in the transaction.
     * @type {number}
     * @memberof WalletTransaction
     */
    'amount': number;
    /**
     * Type of the transaction (credit or debit).
     * @type {string}
     * @memberof WalletTransaction
     */
    'type': WalletTransactionTypeEnum;
    /**
     * Source or reason for the transaction (e.g., payment, refund, transfer).
     * @type {string}
     * @memberof WalletTransaction
     */
    'source': WalletTransactionSourceEnum;
    /**
     * The ID of the source entity associated with this transaction (e.g., an order ID for a payment).
     * @type {string}
     * @memberof WalletTransaction
     */
    'sourceId': string;
    /**
     * Status of the transaction (e.g., success, pending, failed).
     * @type {string}
     * @memberof WalletTransaction
     */
    'status': WalletTransactionStatusEnum;
    /**
     * Optional reference to another transaction (e.g., for refunds or reversals).
     * @type {string}
     * @memberof WalletTransaction
     */
    'relatedTransactionId'?: string;
    /**
     * A brief description or note about the transaction.
     * @type {string}
     * @memberof WalletTransaction
     */
    'narration'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransaction
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransaction
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransaction
     */
    'updatedAt'?: string;
}

export const WalletTransactionTypeEnum = {
    Credit: 'credit',
    Debit: 'debit'
} as const;

export type WalletTransactionTypeEnum = typeof WalletTransactionTypeEnum[keyof typeof WalletTransactionTypeEnum];
export const WalletTransactionSourceEnum = {
    Fund: 'fund',
    Transfer: 'transfer',
    OrderPayment: 'order-payment',
    PreOrderPayment: 'pre-order-payment',
    GiftCardPayment: 'gift-card-payment',
    Payment: 'payment',
    Withdraw: 'withdraw',
    OrderRefund: 'order-refund',
    RiderOrderPayout: 'rider-order-payout'
} as const;

export type WalletTransactionSourceEnum = typeof WalletTransactionSourceEnum[keyof typeof WalletTransactionSourceEnum];
export const WalletTransactionStatusEnum = {
    Success: 'success',
    Pending: 'pending',
    Failed: 'failed'
} as const;

export type WalletTransactionStatusEnum = typeof WalletTransactionStatusEnum[keyof typeof WalletTransactionStatusEnum];

/**
 * 
 * @export
 * @interface WithdrawToBankDTO
 */
export interface WithdrawToBankDTO {
    /**
     * The amount to be withdrawn
     * @type {number}
     * @memberof WithdrawToBankDTO
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface Zone
 */
export interface Zone {
    /**
     * Unique identifier for the zone, automatically generated by MongoDB.
     * @type {object}
     * @memberof Zone
     */
    'id': object;
    /**
     * 
     * @type {ZoneOverviewMeta}
     * @memberof Zone
     */
    'meta'?: ZoneOverviewMeta;
    /**
     * Name of the zone. This should be a human-readable name that clearly identifies the zone, such as \"Rayfield\" or \"GRA\".
     * @type {string}
     * @memberof Zone
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'handle': string;
    /**
     * Zone alias. This is an optional alternative name or short form for the zone, which can be used for display purposes or user convenience.
     * @type {string}
     * @memberof Zone
     */
    'alias'?: string;
    /**
     * Description of the zone. This provides additional context or details about the zone, such as its boundaries, landmarks, or other relevant information.
     * @type {string}
     * @memberof Zone
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Zone
     */
    'areas': Array<string>;
    /**
     * 
     * @type {ZoneConfig}
     * @memberof Zone
     */
    'config': ZoneConfig;
    /**
     * Geographic coordinates (longitude, latitude) of the zone\'s center point. This is used to define the zone\'s location on a map.
     * @type {Array<number>}
     * @memberof Zone
     */
    'coordinates': Array<number>;
    /**
     * Radius of the zone in meters. This defines the circular area around the center point that is considered part of the zone.
     * @type {number}
     * @memberof Zone
     */
    'radius': number;
    /**
     * 
     * @type {ZoneCentralAddress}
     * @memberof Zone
     */
    'address': ZoneCentralAddress;
    /**
     * State or region code within the country where the zone is located. This should be a valid code for the specified country.
     * @type {string}
     * @memberof Zone
     */
    'stateCode': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'averageDeliveryTimeWithinZoneDesc': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'minimumDeliveryFee': string;
    /**
     * 
     * @type {boolean}
     * @memberof Zone
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface ZoneCentralAddress
 */
export interface ZoneCentralAddress {
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'country'?: string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'countryCode'?: string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'state'?: string;
    /**
     * State or region code within the country where the zone is located.
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'stateCode'?: string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'address'?: string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof ZoneCentralAddress
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof ZoneCentralAddress
     */
    'longitude'?: number;
    /**
     * The building number or apartment number of the address.
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'buildingNumber'?: string;
}
/**
 * 
 * @export
 * @interface ZoneConfig
 */
export interface ZoneConfig {
    /**
     * 
     * @type {number}
     * @memberof ZoneConfig
     */
    'averageDeliveryTimeInMins'?: number;
    /**
     * A fixed delivery fee applied to all orders within this zone (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'fixedDeliveryFee'?: number;
    /**
     * A delivery fee applied per kilometer within this zone (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'flatRatePerKm'?: number;
    /**
     * Minimum charge for distance-based delivery (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'minDistanceDeliveryFee'?: number;
    /**
     * Preferred delivery fee type to use for this zone. Can be either \"flat_rate\" or \"distance_based\".
     * @type {string}
     * @memberof ZoneConfig
     */
    'deliveryFeeType'?: ZoneConfigDeliveryFeeTypeEnum;
    /**
     * Enable price increases during specific time slots
     * @type {boolean}
     * @memberof ZoneConfig
     */
    'enablePriceIncrease'?: boolean;
    /**
     * Time slots with price increases
     * @type {Array<PriceIncreaseTimeSlot>}
     * @memberof ZoneConfig
     */
    'priceIncreaseTimeSlots'?: Array<PriceIncreaseTimeSlot>;
}

export const ZoneConfigDeliveryFeeTypeEnum = {
    FlatRate: 'flat_rate',
    DistanceBased: 'distance_based',
    Free: 'free'
} as const;

export type ZoneConfigDeliveryFeeTypeEnum = typeof ZoneConfigDeliveryFeeTypeEnum[keyof typeof ZoneConfigDeliveryFeeTypeEnum];

/**
 * 
 * @export
 * @interface ZoneOverviewMeta
 */
export interface ZoneOverviewMeta {
    /**
     * 
     * @type {number}
     * @memberof ZoneOverviewMeta
     */
    'totalOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof ZoneOverviewMeta
     */
    'totalOutlets'?: number;
}

/**
 * AddonsApi - axios parameter creator
 * @export
 */
export const AddonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyReferrals: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me/my-referrals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddonsApi - functional programming interface
 * @export
 */
export const AddonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddonsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetMyReferrals(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Referral>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetMyReferrals(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.accountControllerGetMyReferrals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddonsApi - factory interface
 * @export
 */
export const AddonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddonsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyReferrals(options?: RawAxiosRequestConfig): AxiosPromise<Array<Referral>> {
            return localVarFp.accountControllerGetMyReferrals(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddonsApi - object-oriented interface
 * @export
 * @class AddonsApi
 * @extends {BaseAPI}
 */
export class AddonsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public accountControllerGetMyReferrals(options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).accountControllerGetMyReferrals(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new address to the user\'s account
         * @param {CustomerAddress} customerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerAddAddress: async (customerAddress: CustomerAddress, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerAddress' is not null or undefined
            assertParamExists('accountControllerAddAddress', 'customerAddress', customerAddress)
            const localVarPath = `/v1/account/me/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an address from the user\'s account
         * @param {string} addressId The ID of the address to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerRemoveAddress: async (addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('accountControllerRemoveAddress', 'addressId', addressId)
            const localVarPath = `/v1/account/me/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new address to the user\'s account
         * @param {UseMyAddressAddressDTO} useMyAddressAddressDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerSetupCurrentAddress: async (useMyAddressAddressDTO: UseMyAddressAddressDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'useMyAddressAddressDTO' is not null or undefined
            assertParamExists('accountControllerSetupCurrentAddress', 'useMyAddressAddressDTO', useMyAddressAddressDTO)
            const localVarPath = `/v1/account/me/my-location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(useMyAddressAddressDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing address in the user\'s account
         * @param {string} addressId The ID of the address to update
         * @param {UpdateCustomerAddress} updateCustomerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAddress: async (addressId: string, updateCustomerAddress: UpdateCustomerAddress, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('accountControllerUpdateAddress', 'addressId', addressId)
            // verify required parameter 'updateCustomerAddress' is not null or undefined
            assertParamExists('accountControllerUpdateAddress', 'updateCustomerAddress', updateCustomerAddress)
            const localVarPath = `/v1/account/me/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address intent data by longitude and latitude
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {AddressControllerAddAddressIntentByCoordinatesProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerAddAddressIntentByCoordinates: async (longitude: number, latitude: number, provider: AddressControllerAddAddressIntentByCoordinatesProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('addressControllerAddAddressIntentByCoordinates', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('addressControllerAddAddressIntentByCoordinates', 'latitude', latitude)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('addressControllerAddAddressIntentByCoordinates', 'provider', provider)
            const localVarPath = `/v1/account/address-hooks/add-intent/coordinates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address intent data by place ID
         * @param {string} placeId The place ID from Mapbox or Google
         * @param {AddressControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerAddAddressIntentByPlaceId: async (placeId: string, provider: AddressControllerAddAddressIntentByPlaceIdProviderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('addressControllerAddAddressIntentByPlaceId', 'placeId', placeId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('addressControllerAddAddressIntentByPlaceId', 'provider', provider)
            const localVarPath = `/v1/account/address-hooks/add-intent/place-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (placeId !== undefined) {
                localVarQueryParameter['placeId'] = placeId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new address to the user\'s account
         * @param {CustomerAddress} customerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerAddAddress(customerAddress: CustomerAddress, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerAddAddress(customerAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.accountControllerAddAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an address from the user\'s account
         * @param {string} addressId The ID of the address to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerRemoveAddress(addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerRemoveAddress(addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.accountControllerRemoveAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a new address to the user\'s account
         * @param {UseMyAddressAddressDTO} useMyAddressAddressDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerSetupCurrentAddress(useMyAddressAddressDTO: UseMyAddressAddressDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerSetupCurrentAddress(useMyAddressAddressDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.accountControllerSetupCurrentAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing address in the user\'s account
         * @param {string} addressId The ID of the address to update
         * @param {UpdateCustomerAddress} updateCustomerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAddress(addressId: string, updateCustomerAddress: UpdateCustomerAddress, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAddress(addressId, updateCustomerAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.accountControllerUpdateAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get address intent data by longitude and latitude
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {AddressControllerAddAddressIntentByCoordinatesProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerAddAddressIntentByCoordinates(longitude: number, latitude: number, provider: AddressControllerAddAddressIntentByCoordinatesProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerAddAddressIntentByCoordinates(longitude, latitude, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerAddAddressIntentByCoordinates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get address intent data by place ID
         * @param {string} placeId The place ID from Mapbox or Google
         * @param {AddressControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressControllerAddAddressIntentByPlaceId(placeId: string, provider: AddressControllerAddAddressIntentByPlaceIdProviderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressControllerAddAddressIntentByPlaceId(placeId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddressesApi.addressControllerAddAddressIntentByPlaceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new address to the user\'s account
         * @param {CustomerAddress} customerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerAddAddress(customerAddress: CustomerAddress, options?: RawAxiosRequestConfig): AxiosPromise<CustomerAddress> {
            return localVarFp.accountControllerAddAddress(customerAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an address from the user\'s account
         * @param {string} addressId The ID of the address to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerRemoveAddress(addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerRemoveAddress(addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new address to the user\'s account
         * @param {UseMyAddressAddressDTO} useMyAddressAddressDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerSetupCurrentAddress(useMyAddressAddressDTO: UseMyAddressAddressDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerSetupCurrentAddress(useMyAddressAddressDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing address in the user\'s account
         * @param {string} addressId The ID of the address to update
         * @param {UpdateCustomerAddress} updateCustomerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAddress(addressId: string, updateCustomerAddress: UpdateCustomerAddress, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateAddress(addressId, updateCustomerAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address intent data by longitude and latitude
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {AddressControllerAddAddressIntentByCoordinatesProviderEnum} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerAddAddressIntentByCoordinates(longitude: number, latitude: number, provider: AddressControllerAddAddressIntentByCoordinatesProviderEnum, options?: RawAxiosRequestConfig): AxiosPromise<AddressIntentResponse> {
            return localVarFp.addressControllerAddAddressIntentByCoordinates(longitude, latitude, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address intent data by place ID
         * @param {string} placeId The place ID from Mapbox or Google
         * @param {AddressControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressControllerAddAddressIntentByPlaceId(placeId: string, provider: AddressControllerAddAddressIntentByPlaceIdProviderEnum, options?: RawAxiosRequestConfig): AxiosPromise<AddressIntentResponse> {
            return localVarFp.addressControllerAddAddressIntentByPlaceId(placeId, provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * 
     * @summary Add a new address to the user\'s account
     * @param {CustomerAddress} customerAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public accountControllerAddAddress(customerAddress: CustomerAddress, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).accountControllerAddAddress(customerAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an address from the user\'s account
     * @param {string} addressId The ID of the address to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public accountControllerRemoveAddress(addressId: string, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).accountControllerRemoveAddress(addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new address to the user\'s account
     * @param {UseMyAddressAddressDTO} useMyAddressAddressDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public accountControllerSetupCurrentAddress(useMyAddressAddressDTO: UseMyAddressAddressDTO, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).accountControllerSetupCurrentAddress(useMyAddressAddressDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing address in the user\'s account
     * @param {string} addressId The ID of the address to update
     * @param {UpdateCustomerAddress} updateCustomerAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public accountControllerUpdateAddress(addressId: string, updateCustomerAddress: UpdateCustomerAddress, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).accountControllerUpdateAddress(addressId, updateCustomerAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address intent data by longitude and latitude
     * @param {number} longitude 
     * @param {number} latitude 
     * @param {AddressControllerAddAddressIntentByCoordinatesProviderEnum} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public addressControllerAddAddressIntentByCoordinates(longitude: number, latitude: number, provider: AddressControllerAddAddressIntentByCoordinatesProviderEnum, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerAddAddressIntentByCoordinates(longitude, latitude, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address intent data by place ID
     * @param {string} placeId The place ID from Mapbox or Google
     * @param {AddressControllerAddAddressIntentByPlaceIdProviderEnum} provider The provider of the place ID (\&quot;google\&quot; or \&quot;mapbox\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public addressControllerAddAddressIntentByPlaceId(placeId: string, provider: AddressControllerAddAddressIntentByPlaceIdProviderEnum, options?: RawAxiosRequestConfig) {
        return AddressesApiFp(this.configuration).addressControllerAddAddressIntentByPlaceId(placeId, provider, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AddressControllerAddAddressIntentByCoordinatesProviderEnum = {
    Google: 'google',
    Mapbox: 'mapbox'
} as const;
export type AddressControllerAddAddressIntentByCoordinatesProviderEnum = typeof AddressControllerAddAddressIntentByCoordinatesProviderEnum[keyof typeof AddressControllerAddAddressIntentByCoordinatesProviderEnum];
/**
 * @export
 */
export const AddressControllerAddAddressIntentByPlaceIdProviderEnum = {
    Google: 'google',
    Mapbox: 'mapbox'
} as const;
export type AddressControllerAddAddressIntentByPlaceIdProviderEnum = typeof AddressControllerAddAddressIntentByPlaceIdProviderEnum[keyof typeof AddressControllerAddAddressIntentByPlaceIdProviderEnum];


/**
 * CardsApi - axios parameter creator
 * @export
 */
export const CardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Paystack transaction authorization intent for adding a new card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCreateAddCardAuthorizationIntent: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me/cards/authorization-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a saved card from the user\'s account
         * @param {string} cardId The ID of the card to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerRemoveCard: async (cardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('accountControllerRemoveCard', 'cardId', cardId)
            const localVarPath = `/v1/account/me/cards/{cardId}`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Paystack transaction authorization intent for adding a new card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerCreateAddCardAuthorizationIntent(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerCreateAddCardAuthorizationIntent(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.accountControllerCreateAddCardAuthorizationIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a saved card from the user\'s account
         * @param {string} cardId The ID of the card to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerRemoveCard(cardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerRemoveCard(cardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.accountControllerRemoveCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Paystack transaction authorization intent for adding a new card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCreateAddCardAuthorizationIntent(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerCreateAddCardAuthorizationIntent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a saved card from the user\'s account
         * @param {string} cardId The ID of the card to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerRemoveCard(cardId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerRemoveCard(cardId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Paystack transaction authorization intent for adding a new card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public accountControllerCreateAddCardAuthorizationIntent(options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).accountControllerCreateAddCardAuthorizationIntent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a saved card from the user\'s account
     * @param {string} cardId The ID of the card to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public accountControllerRemoveCard(cardId: string, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).accountControllerRemoveCard(cardId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Mark an address as active
         * @param {string} addressId The ID of the address to mark as active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerMarkAddressAsActive: async (addressId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('accountControllerMarkAddressAsActive', 'addressId', addressId)
            const localVarPath = `/v1/account/me/addresses/{addressId}/activate`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Mark an address as active
         * @param {string} addressId The ID of the address to mark as active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerMarkAddressAsActive(addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerMarkAddressAsActive(addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.accountControllerMarkAddressAsActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Mark an address as active
         * @param {string} addressId The ID of the address to mark as active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerMarkAddressAsActive(addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerMarkAddressAsActive(addressId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Mark an address as active
     * @param {string} addressId The ID of the address to mark as active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountControllerMarkAddressAsActive(addressId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountControllerMarkAddressAsActive(addressId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageContactInfoApi - axios parameter creator
 * @export
 */
export const ManageContactInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update account email
         * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerUpdateEmail: async (updateAccountEmailDTO: UpdateAccountEmailDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountEmailDTO' is not null or undefined
            assertParamExists('updateAccountContactControllerUpdateEmail', 'updateAccountEmailDTO', updateAccountEmailDTO)
            const localVarPath = `/v1/account/contact/update-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountEmailDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account phone number
         * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerUpdatePhone: async (updateAccountPhoneDTO: UpdateAccountPhoneDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountPhoneDTO' is not null or undefined
            assertParamExists('updateAccountContactControllerUpdatePhone', 'updateAccountPhoneDTO', updateAccountPhoneDTO)
            const localVarPath = `/v1/account/contact/update-phone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountPhoneDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify new email with OTP
         * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerVerifyEmail: async (verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyNewAccountEmailDTO' is not null or undefined
            assertParamExists('updateAccountContactControllerVerifyEmail', 'verifyNewAccountEmailDTO', verifyNewAccountEmailDTO)
            const localVarPath = `/v1/account/contact/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyNewAccountEmailDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify new phone number with OTP
         * @param {VerifyNewAccountPhoneDTO} verifyNewAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerVerifyPhone: async (verifyNewAccountPhoneDTO: VerifyNewAccountPhoneDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyNewAccountPhoneDTO' is not null or undefined
            assertParamExists('updateAccountContactControllerVerifyPhone', 'verifyNewAccountPhoneDTO', verifyNewAccountPhoneDTO)
            const localVarPath = `/v1/account/contact/verify-phone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyNewAccountPhoneDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageContactInfoApi - functional programming interface
 * @export
 */
export const ManageContactInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageContactInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update account email
         * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountContactControllerUpdateEmail(updateAccountEmailDTO: UpdateAccountEmailDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountContactControllerUpdateEmail(updateAccountEmailDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.updateAccountContactControllerUpdateEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update account phone number
         * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountContactControllerUpdatePhone(updateAccountPhoneDTO: UpdateAccountPhoneDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountContactControllerUpdatePhone(updateAccountPhoneDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.updateAccountContactControllerUpdatePhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify new email with OTP
         * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountContactControllerVerifyEmail(verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountContactControllerVerifyEmail(verifyNewAccountEmailDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.updateAccountContactControllerVerifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify new phone number with OTP
         * @param {VerifyNewAccountPhoneDTO} verifyNewAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountContactControllerVerifyPhone(verifyNewAccountPhoneDTO: VerifyNewAccountPhoneDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountContactControllerVerifyPhone(verifyNewAccountPhoneDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.updateAccountContactControllerVerifyPhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageContactInfoApi - factory interface
 * @export
 */
export const ManageContactInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageContactInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Update account email
         * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerUpdateEmail(updateAccountEmailDTO: UpdateAccountEmailDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAccountContactControllerUpdateEmail(updateAccountEmailDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account phone number
         * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerUpdatePhone(updateAccountPhoneDTO: UpdateAccountPhoneDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAccountContactControllerUpdatePhone(updateAccountPhoneDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify new email with OTP
         * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerVerifyEmail(verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAccountContactControllerVerifyEmail(verifyNewAccountEmailDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify new phone number with OTP
         * @param {VerifyNewAccountPhoneDTO} verifyNewAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountContactControllerVerifyPhone(verifyNewAccountPhoneDTO: VerifyNewAccountPhoneDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAccountContactControllerVerifyPhone(verifyNewAccountPhoneDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageContactInfoApi - object-oriented interface
 * @export
 * @class ManageContactInfoApi
 * @extends {BaseAPI}
 */
export class ManageContactInfoApi extends BaseAPI {
    /**
     * 
     * @summary Update account email
     * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public updateAccountContactControllerUpdateEmail(updateAccountEmailDTO: UpdateAccountEmailDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).updateAccountContactControllerUpdateEmail(updateAccountEmailDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account phone number
     * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public updateAccountContactControllerUpdatePhone(updateAccountPhoneDTO: UpdateAccountPhoneDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).updateAccountContactControllerUpdatePhone(updateAccountPhoneDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify new email with OTP
     * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public updateAccountContactControllerVerifyEmail(verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).updateAccountContactControllerVerifyEmail(verifyNewAccountEmailDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify new phone number with OTP
     * @param {VerifyNewAccountPhoneDTO} verifyNewAccountPhoneDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public updateAccountContactControllerVerifyPhone(verifyNewAccountPhoneDTO: VerifyNewAccountPhoneDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).updateAccountContactControllerVerifyPhone(verifyNewAccountPhoneDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteMyAccount: async (deleteAccountDTO: DeleteAccountDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAccountDTO' is not null or undefined
            assertParamExists('accountControllerDeleteMyAccount', 'deleteAccountDTO', deleteAccountDTO)
            const localVarPath = `/v1/account/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAccountDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetCounter: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me/counter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyProfileDetailed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me/detailed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAccountDTO} updateAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccount: async (updateAccountDTO: UpdateAccountDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountDTO' is not null or undefined
            assertParamExists('accountControllerUpdateAccount', 'updateAccountDTO', updateAccountDTO)
            const localVarPath = `/v1/account/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateConnectedPayoutProfileDTO} updateConnectedPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateConnectedPayoutProfile: async (updateConnectedPayoutProfileDTO: UpdateConnectedPayoutProfileDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateConnectedPayoutProfileDTO' is not null or undefined
            assertParamExists('accountControllerUpdateConnectedPayoutProfile', 'updateConnectedPayoutProfileDTO', updateConnectedPayoutProfileDTO)
            const localVarPath = `/v1/account/me/connected-payout-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConnectedPayoutProfileDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateFCMToken: async (updateFCMTokenDTO: UpdateFCMTokenDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateFCMTokenDTO' is not null or undefined
            assertParamExists('accountControllerUpdateFCMToken', 'updateFCMTokenDTO', updateFCMTokenDTO)
            const localVarPath = `/v1/account/me/update-fcm-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFCMTokenDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdatePassword: async (updateAccountPasswordDTO: UpdateAccountPasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountPasswordDTO' is not null or undefined
            assertParamExists('accountControllerUpdatePassword', 'updateAccountPasswordDTO', updateAccountPasswordDTO)
            const localVarPath = `/v1/account/me/update-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountPasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerDeleteMyAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerDeleteMyAccount(deleteAccountDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerDeleteMyAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetCounter(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetCounter(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerGetCounter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetMyProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPublicDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetMyProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerGetMyProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetMyProfileDetailed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetMyProfileDetailed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerGetMyProfileDetailed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateAccountDTO} updateAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAccount(updateAccountDTO: UpdateAccountDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAccount(updateAccountDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateConnectedPayoutProfileDTO} updateConnectedPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateConnectedPayoutProfile(updateConnectedPayoutProfileDTO: UpdateConnectedPayoutProfileDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateConnectedPayoutProfile(updateConnectedPayoutProfileDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdateConnectedPayoutProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateFCMToken(updateFCMTokenDTO: UpdateFCMTokenDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateFCMToken(updateFCMTokenDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdateFCMToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdatePassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdatePassword(updateAccountPasswordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteMyAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerDeleteMyAccount(deleteAccountDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetCounter(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerGetCounter(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyProfile(options?: RawAxiosRequestConfig): AxiosPromise<AccountPublicDto> {
            return localVarFp.accountControllerGetMyProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMyProfileDetailed(options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.accountControllerGetMyProfileDetailed(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateAccountDTO} updateAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccount(updateAccountDTO: UpdateAccountDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateAccount(updateAccountDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateConnectedPayoutProfileDTO} updateConnectedPayoutProfileDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateConnectedPayoutProfile(updateConnectedPayoutProfileDTO: UpdateConnectedPayoutProfileDTO, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.accountControllerUpdateConnectedPayoutProfile(updateConnectedPayoutProfileDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateFCMToken(updateFCMTokenDTO: UpdateFCMTokenDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateFCMToken(updateFCMTokenDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdatePassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerUpdatePassword(updateAccountPasswordDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * 
     * @param {DeleteAccountDTO} deleteAccountDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerDeleteMyAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerDeleteMyAccount(deleteAccountDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerGetCounter(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerGetCounter(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerGetMyProfile(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerGetMyProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerGetMyProfileDetailed(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerGetMyProfileDetailed(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateAccountDTO} updateAccountDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdateAccount(updateAccountDTO: UpdateAccountDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdateAccount(updateAccountDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateConnectedPayoutProfileDTO} updateConnectedPayoutProfileDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdateConnectedPayoutProfile(updateConnectedPayoutProfileDTO: UpdateConnectedPayoutProfileDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdateConnectedPayoutProfile(updateConnectedPayoutProfileDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdateFCMToken(updateFCMTokenDTO: UpdateFCMTokenDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdateFCMToken(updateFCMTokenDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdatePassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdatePassword(updateAccountPasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyWalletApi - axios parameter creator
 * @export
 */
export const MyWalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate a user\'s wallet (Owner)
         * @param {ActivateWalletDTO} activateWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerActivateWallet: async (activateWalletDTO: ActivateWalletDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activateWalletDTO' is not null or undefined
            assertParamExists('myWalletWalletControllerActivateWallet', 'activateWalletDTO', activateWalletDTO)
            const localVarPath = `/v1/account/my-wallet/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateWalletDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deactivate a user\'s wallet (Owner)
         * @param {DeactivateWalletDTO} deactivateWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerDeactivateWallet: async (deactivateWalletDTO: DeactivateWalletDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deactivateWalletDTO' is not null or undefined
            assertParamExists('myWalletWalletControllerDeactivateWallet', 'deactivateWalletDTO', deactivateWalletDTO)
            const localVarPath = `/v1/account/my-wallet/deactivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deactivateWalletDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fund wallet intent
         * @param {FundWalletIntentPayWithPaystack} fundWalletIntentPayWithPaystack 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerFundWalletIntentPayWithPaystack: async (fundWalletIntentPayWithPaystack: FundWalletIntentPayWithPaystack, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundWalletIntentPayWithPaystack' is not null or undefined
            assertParamExists('myWalletWalletControllerFundWalletIntentPayWithPaystack', 'fundWalletIntentPayWithPaystack', fundWalletIntentPayWithPaystack)
            const localVarPath = `/v1/account/my-wallet/fund-wallet-intent/paystack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundWalletIntentPayWithPaystack, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fund wallet intent
         * @param {FundWalletIntentPayWithCard} fundWalletIntentPayWithCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerFundWalletIntentPayWithPaystackCard: async (fundWalletIntentPayWithCard: FundWalletIntentPayWithCard, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundWalletIntentPayWithCard' is not null or undefined
            assertParamExists('myWalletWalletControllerFundWalletIntentPayWithPaystackCard', 'fundWalletIntentPayWithCard', fundWalletIntentPayWithCard)
            const localVarPath = `/v1/account/my-wallet/fund-wallet-intent/paystack-card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundWalletIntentPayWithCard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wallet attached to logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerGetMyWallet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/my-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction history for a wallet
         * @param {string} walletId ID of the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerGetWalletHistory: async (walletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('myWalletWalletControllerGetWalletHistory', 'walletId', walletId)
            const localVarPath = `/v1/account/my-wallet/{walletId}/history`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer funds between wallets
         * @param {TransferBetweenWalletsDTO} transferBetweenWalletsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerTransferBetweenWallets: async (transferBetweenWalletsDTO: TransferBetweenWalletsDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferBetweenWalletsDTO' is not null or undefined
            assertParamExists('myWalletWalletControllerTransferBetweenWallets', 'transferBetweenWalletsDTO', transferBetweenWalletsDTO)
            const localVarPath = `/v1/account/my-wallet/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferBetweenWalletsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer funds from the authenticated user\'s wallet to another user\'s wallet
         * @param {TransferToUserWalletDTO} transferToUserWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerTransferToUserWallet: async (transferToUserWalletDTO: TransferToUserWalletDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferToUserWalletDTO' is not null or undefined
            assertParamExists('myWalletWalletControllerTransferToUserWallet', 'transferToUserWalletDTO', transferToUserWalletDTO)
            const localVarPath = `/v1/account/my-wallet/transfer-to-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferToUserWalletDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Withdraw from wallet to a linked bank account
         * @param {WithdrawToBankDTO} withdrawToBankDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerWithdrawToBank: async (withdrawToBankDTO: WithdrawToBankDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawToBankDTO' is not null or undefined
            assertParamExists('myWalletWalletControllerWithdrawToBank', 'withdrawToBankDTO', withdrawToBankDTO)
            const localVarPath = `/v1/account/my-wallet/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawToBankDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyWalletApi - functional programming interface
 * @export
 */
export const MyWalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyWalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activate a user\'s wallet (Owner)
         * @param {ActivateWalletDTO} activateWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerActivateWallet(activateWalletDTO: ActivateWalletDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerActivateWallet(activateWalletDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerActivateWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deactivate a user\'s wallet (Owner)
         * @param {DeactivateWalletDTO} deactivateWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerDeactivateWallet(deactivateWalletDTO: DeactivateWalletDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerDeactivateWallet(deactivateWalletDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerDeactivateWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fund wallet intent
         * @param {FundWalletIntentPayWithPaystack} fundWalletIntentPayWithPaystack 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerFundWalletIntentPayWithPaystack(fundWalletIntentPayWithPaystack: FundWalletIntentPayWithPaystack, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerFundWalletIntentPayWithPaystack(fundWalletIntentPayWithPaystack, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerFundWalletIntentPayWithPaystack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fund wallet intent
         * @param {FundWalletIntentPayWithCard} fundWalletIntentPayWithCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerFundWalletIntentPayWithPaystackCard(fundWalletIntentPayWithCard: FundWalletIntentPayWithCard, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerFundWalletIntentPayWithPaystackCard(fundWalletIntentPayWithCard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerFundWalletIntentPayWithPaystackCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get wallet attached to logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerGetMyWallet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerGetMyWallet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerGetMyWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get transaction history for a wallet
         * @param {string} walletId ID of the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerGetWalletHistory(walletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WalletTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerGetWalletHistory(walletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerGetWalletHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transfer funds between wallets
         * @param {TransferBetweenWalletsDTO} transferBetweenWalletsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerTransferBetweenWallets(transferBetweenWalletsDTO: TransferBetweenWalletsDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerTransferBetweenWallets(transferBetweenWalletsDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerTransferBetweenWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transfer funds from the authenticated user\'s wallet to another user\'s wallet
         * @param {TransferToUserWalletDTO} transferToUserWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerTransferToUserWallet(transferToUserWalletDTO: TransferToUserWalletDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerTransferToUserWallet(transferToUserWalletDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerTransferToUserWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Withdraw from wallet to a linked bank account
         * @param {WithdrawToBankDTO} withdrawToBankDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myWalletWalletControllerWithdrawToBank(withdrawToBankDTO: WithdrawToBankDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.myWalletWalletControllerWithdrawToBank(withdrawToBankDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyWalletApi.myWalletWalletControllerWithdrawToBank']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyWalletApi - factory interface
 * @export
 */
export const MyWalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyWalletApiFp(configuration)
    return {
        /**
         * 
         * @summary Activate a user\'s wallet (Owner)
         * @param {ActivateWalletDTO} activateWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerActivateWallet(activateWalletDTO: ActivateWalletDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.myWalletWalletControllerActivateWallet(activateWalletDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deactivate a user\'s wallet (Owner)
         * @param {DeactivateWalletDTO} deactivateWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerDeactivateWallet(deactivateWalletDTO: DeactivateWalletDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.myWalletWalletControllerDeactivateWallet(deactivateWalletDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fund wallet intent
         * @param {FundWalletIntentPayWithPaystack} fundWalletIntentPayWithPaystack 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerFundWalletIntentPayWithPaystack(fundWalletIntentPayWithPaystack: FundWalletIntentPayWithPaystack, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.myWalletWalletControllerFundWalletIntentPayWithPaystack(fundWalletIntentPayWithPaystack, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fund wallet intent
         * @param {FundWalletIntentPayWithCard} fundWalletIntentPayWithCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerFundWalletIntentPayWithPaystackCard(fundWalletIntentPayWithCard: FundWalletIntentPayWithCard, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.myWalletWalletControllerFundWalletIntentPayWithPaystackCard(fundWalletIntentPayWithCard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wallet attached to logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerGetMyWallet(options?: RawAxiosRequestConfig): AxiosPromise<Wallet> {
            return localVarFp.myWalletWalletControllerGetMyWallet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction history for a wallet
         * @param {string} walletId ID of the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerGetWalletHistory(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WalletTransaction>> {
            return localVarFp.myWalletWalletControllerGetWalletHistory(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer funds between wallets
         * @param {TransferBetweenWalletsDTO} transferBetweenWalletsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerTransferBetweenWallets(transferBetweenWalletsDTO: TransferBetweenWalletsDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.myWalletWalletControllerTransferBetweenWallets(transferBetweenWalletsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer funds from the authenticated user\'s wallet to another user\'s wallet
         * @param {TransferToUserWalletDTO} transferToUserWalletDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerTransferToUserWallet(transferToUserWalletDTO: TransferToUserWalletDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.myWalletWalletControllerTransferToUserWallet(transferToUserWalletDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Withdraw from wallet to a linked bank account
         * @param {WithdrawToBankDTO} withdrawToBankDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myWalletWalletControllerWithdrawToBank(withdrawToBankDTO: WithdrawToBankDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.myWalletWalletControllerWithdrawToBank(withdrawToBankDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MyWalletApi - object-oriented interface
 * @export
 * @class MyWalletApi
 * @extends {BaseAPI}
 */
export class MyWalletApi extends BaseAPI {
    /**
     * 
     * @summary Activate a user\'s wallet (Owner)
     * @param {ActivateWalletDTO} activateWalletDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerActivateWallet(activateWalletDTO: ActivateWalletDTO, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerActivateWallet(activateWalletDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deactivate a user\'s wallet (Owner)
     * @param {DeactivateWalletDTO} deactivateWalletDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerDeactivateWallet(deactivateWalletDTO: DeactivateWalletDTO, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerDeactivateWallet(deactivateWalletDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fund wallet intent
     * @param {FundWalletIntentPayWithPaystack} fundWalletIntentPayWithPaystack 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerFundWalletIntentPayWithPaystack(fundWalletIntentPayWithPaystack: FundWalletIntentPayWithPaystack, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerFundWalletIntentPayWithPaystack(fundWalletIntentPayWithPaystack, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fund wallet intent
     * @param {FundWalletIntentPayWithCard} fundWalletIntentPayWithCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerFundWalletIntentPayWithPaystackCard(fundWalletIntentPayWithCard: FundWalletIntentPayWithCard, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerFundWalletIntentPayWithPaystackCard(fundWalletIntentPayWithCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wallet attached to logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerGetMyWallet(options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerGetMyWallet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction history for a wallet
     * @param {string} walletId ID of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerGetWalletHistory(walletId: string, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerGetWalletHistory(walletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer funds between wallets
     * @param {TransferBetweenWalletsDTO} transferBetweenWalletsDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerTransferBetweenWallets(transferBetweenWalletsDTO: TransferBetweenWalletsDTO, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerTransferBetweenWallets(transferBetweenWalletsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer funds from the authenticated user\'s wallet to another user\'s wallet
     * @param {TransferToUserWalletDTO} transferToUserWalletDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerTransferToUserWallet(transferToUserWalletDTO: TransferToUserWalletDTO, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerTransferToUserWallet(transferToUserWalletDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Withdraw from wallet to a linked bank account
     * @param {WithdrawToBankDTO} withdrawToBankDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyWalletApi
     */
    public myWalletWalletControllerWithdrawToBank(withdrawToBankDTO: WithdrawToBankDTO, options?: RawAxiosRequestConfig) {
        return MyWalletApiFp(this.configuration).myWalletWalletControllerWithdrawToBank(withdrawToBankDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file without transformations
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadFile: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/upload/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadImage: async (type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/upload/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file without transformations
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadControllerUploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.imageUploadControllerUploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadControllerUploadImage(type, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.imageUploadControllerUploadImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file without transformations
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResult> {
            return localVarFp.imageUploadControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResult> {
            return localVarFp.imageUploadControllerUploadImage(type, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file without transformations
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).imageUploadControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload an image with optional resizing
     * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).imageUploadControllerUploadImage(type, file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ImageUploadControllerUploadImageTypeEnum = {
    Thumbnail: 'thumbnail',
    Logo: 'logo',
    ProductImage: 'product-image',
    CoverImage: 'cover-image',
    Medium: 'medium',
    Large: 'large'
} as const;
export type ImageUploadControllerUploadImageTypeEnum = typeof ImageUploadControllerUploadImageTypeEnum[keyof typeof ImageUploadControllerUploadImageTypeEnum];


/**
 * UserListApi - axios parameter creator
 * @export
 */
export const UserListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerAddItemToList: async (addListItemDTO: AddListItemDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addListItemDTO' is not null or undefined
            assertParamExists('listItemControllerAddItemToList', 'addListItemDTO', addListItemDTO)
            const localVarPath = `/v1/account/list-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addListItemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerGetUserList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/list-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {string} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerRemoveItemFromList: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('listItemControllerRemoveItemFromList', 'itemId', itemId)
            const localVarPath = `/v1/account/list-items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserListApi - functional programming interface
 * @export
 */
export const UserListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserListApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerAddItemToList(addListItemDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerAddItemToList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerGetUserList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerGetUserList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerGetUserList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {string} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerRemoveItemFromList(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerRemoveItemFromList(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerRemoveItemFromList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserListApi - factory interface
 * @export
 */
export const UserListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserListApiFp(configuration)
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listItemControllerAddItemToList(addListItemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerGetUserList(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listItemControllerGetUserList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {string} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerRemoveItemFromList(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listItemControllerRemoveItemFromList(itemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserListApi - object-oriented interface
 * @export
 * @class UserListApi
 * @extends {BaseAPI}
 */
export class UserListApi extends BaseAPI {
    /**
     * 
     * @summary Add an item to a user\'s list
     * @param {AddListItemDTO} addListItemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerAddItemToList(addListItemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all list items for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerGetUserList(options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerGetUserList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an item from a user\'s list
     * @param {string} itemId ID of the list item to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerRemoveItemFromList(itemId: string, options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerRemoveItemFromList(itemId, options).then((request) => request(this.axios, this.basePath));
    }
}



