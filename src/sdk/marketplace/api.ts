/* tslint:disable */
/* eslint-disable */
/**
 * Marketplace Docs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddCartItemDTO
 */
export interface AddCartItemDTO {
    /**
     * The ID of the product in this cart item.
     * @type {string}
     * @memberof AddCartItemDTO
     */
    'productId': string;
    /**
     * Cart item name
     * @type {string}
     * @memberof AddCartItemDTO
     */
    'name': string;
    /**
     * Image url
     * @type {string}
     * @memberof AddCartItemDTO
     */
    'imageUrl': string;
    /**
     * The quantity of the product in this cart item.
     * @type {number}
     * @memberof AddCartItemDTO
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof AddCartItemDTO
     */
    'unitPrice'?: number;
    /**
     * An array of addons associated with this cart item.
     * @type {Array<CartAddon>}
     * @memberof AddCartItemDTO
     */
    'addons'?: Array<CartAddon>;
}
/**
 * 
 * @export
 * @interface AddonGroup
 */
export interface AddonGroup {
    /**
     * Unique identifier for the addon group, automatically generated by MongoDB.
     * @type {string}
     * @memberof AddonGroup
     */
    'id': string;
    /**
     * Outlet ID to which this addon group belongs.
     * @type {string}
     * @memberof AddonGroup
     */
    'outletId': string;
    /**
     * Name of the addon group. This should be a clear and descriptive name that categorizes the addons within this group, e.g., \"Toppings\", \"Sauces\", or \"Sides\".
     * @type {string}
     * @memberof AddonGroup
     */
    'name': string;
    /**
     * Optional description of the addon group. This can provide additional context or information about the types of addons within this group.
     * @type {string}
     * @memberof AddonGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddonGroup
     */
    'minimumSelect'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddonGroup
     */
    'maximumSelect'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddonGroup
     */
    'required'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddonGroup
     */
    'type'?: AddonGroupTypeEnum;
    /**
     * An array of productAddons
     * @type {Array<ProductAddon>}
     * @memberof AddonGroup
     */
    'items': Array<ProductAddon>;
    /**
     * Timestamp when the product was created.
     * @type {string}
     * @memberof AddonGroup
     */
    'createdAt': string;
    /**
     * Timestamp when the product was last updated.
     * @type {string}
     * @memberof AddonGroup
     */
    'updatedAt': string;
}

export const AddonGroupTypeEnum = {
    SingleChoice: 'single-choice',
    MultiSelect: 'multi-select'
} as const;

export type AddonGroupTypeEnum = typeof AddonGroupTypeEnum[keyof typeof AddonGroupTypeEnum];

/**
 * 
 * @export
 * @interface AdsEntry
 */
export interface AdsEntry {
    /**
     * Unique identifier for the ads entry, automatically generated by MongoDB.
     * @type {string}
     * @memberof AdsEntry
     */
    'id': string;
    /**
     * The ID of the zone where this ad should be displayed.
     * @type {string}
     * @memberof AdsEntry
     */
    'zoneId': string;
    /**
     * The URL of the image to be displayed in the ad.
     * @type {string}
     * @memberof AdsEntry
     */
    'verticalImageUrl'?: string;
    /**
     * The URL of the image to be displayed in the ad.
     * @type {string}
     * @memberof AdsEntry
     */
    'horizontalImageUrl': string;
    /**
     * The title or headline of the ad (optional).
     * @type {string}
     * @memberof AdsEntry
     */
    'title'?: string;
    /**
     * The URL the ad should link to when clicked (optional).
     * @type {string}
     * @memberof AdsEntry
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdsEntry
     */
    'description'?: string;
    /**
     * The ID of the account (vendor or other entity) associated with this ad.
     * @type {string}
     * @memberof AdsEntry
     */
    'relatedAccountId'?: string;
    /**
     * The type of account this ad is related to.
     * @type {string}
     * @memberof AdsEntry
     */
    'relatedAccountType'?: string;
    /**
     * The duration (in seconds) for which this ad should be displayed.
     * @type {number}
     * @memberof AdsEntry
     */
    'duration'?: number;
    /**
     * Timestamp when the ad entry was created.
     * @type {string}
     * @memberof AdsEntry
     */
    'createdAt': string;
    /**
     * Timestamp when the ad entry was last updated.
     * @type {string}
     * @memberof AdsEntry
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CancelOrderDTO
 */
export interface CancelOrderDTO {
    /**
     * Indicates who is cancelling the order (customer or vendor).
     * @type {string}
     * @memberof CancelOrderDTO
     */
    'who': CancelOrderDTOWhoEnum;
    /**
     * The reason for cancelling the order.
     * @type {string}
     * @memberof CancelOrderDTO
     */
    'reason': string;
}

export const CancelOrderDTOWhoEnum = {
    Vendor: 'vendor',
    Admin: 'admin',
    Customer: 'customer'
} as const;

export type CancelOrderDTOWhoEnum = typeof CancelOrderDTOWhoEnum[keyof typeof CancelOrderDTOWhoEnum];

/**
 * 
 * @export
 * @interface CartAddon
 */
export interface CartAddon {
    /**
     * 
     * @type {string}
     * @memberof CartAddon
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CartAddon
     */
    'groupId': string;
    /**
     * Name of the addon.
     * @type {string}
     * @memberof CartAddon
     */
    'name': string;
    /**
     * Price of the addon.
     * @type {number}
     * @memberof CartAddon
     */
    'price': number;
    /**
     * Price of the addon.
     * @type {number}
     * @memberof CartAddon
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface CartItem
 */
export interface CartItem {
    /**
     * Unique identifier for the cart item, automatically generated by MongoDB.
     * @type {string}
     * @memberof CartItem
     */
    'id': string;
    /**
     * The ID of the customer associated with this cart item.
     * @type {object}
     * @memberof CartItem
     */
    'accountId': object;
    /**
     * The ID of the outlet where this cart item is from.
     * @type {object}
     * @memberof CartItem
     */
    'outletId': object;
    /**
     * The ID of the product in this cart item.
     * @type {string}
     * @memberof CartItem
     */
    'productId': string;
    /**
     * Cart item name
     * @type {string}
     * @memberof CartItem
     */
    'name': string;
    /**
     * Image url
     * @type {string}
     * @memberof CartItem
     */
    'imageUrl': string;
    /**
     * The quantity of the product in this cart item.
     * @type {number}
     * @memberof CartItem
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof CartItem
     */
    'unitPrice'?: number;
    /**
     * An array of addons associated with this cart item.
     * @type {Array<CartAddon>}
     * @memberof CartItem
     */
    'addons'?: Array<CartAddon>;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Unique identifier for the category, automatically generated by MongoDB.
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * Unique identifier for the outlet to which this category belongs.
     * @type {string}
     * @memberof Category
     */
    'outletId': string;
    /**
     * Name of the category, specific to the outlet.
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * Optional description providing more details about the category.
     * @type {string}
     * @memberof Category
     */
    'description'?: string;
    /**
     * URL to an image representing the category.
     * @type {string}
     * @memberof Category
     */
    'imageUrl'?: string;
    /**
     * The slugified version of the category name for URL paths.
     * @type {string}
     * @memberof Category
     */
    'handle'?: string;
    /**
     * Order of the category
     * @type {number}
     * @memberof Category
     */
    'order'?: number;
    /**
     * Parent category for nested category structures within the same outlet.
     * @type {string}
     * @memberof Category
     */
    'parentCategoryId'?: string;
}
/**
 * 
 * @export
 * @interface CustomerAddress
 */
export interface CustomerAddress {
    /**
     * 
     * @type {string}
     * @memberof CustomerAddress
     */
    'id'?: string;
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof CustomerAddress
     */
    'country'?: string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof CustomerAddress
     */
    'countryCode'?: string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof CustomerAddress
     */
    'state'?: string;
    /**
     * State or region code within the country where the zone is located.
     * @type {string}
     * @memberof CustomerAddress
     */
    'stateCode'?: string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof CustomerAddress
     */
    'address'?: string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof CustomerAddress
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof CustomerAddress
     */
    'longitude'?: number;
    /**
     * Additional notes or instructions for the address
     * @type {string}
     * @memberof CustomerAddress
     */
    'notes'?: string;
    /**
     * The type or category of the address.
     * @type {string}
     * @memberof CustomerAddress
     */
    'type'?: CustomerAddressTypeEnum;
    /**
     * A nearby landmark or easily recognizable location near the address.
     * @type {string}
     * @memberof CustomerAddress
     */
    'landmark'?: string;
    /**
     * The ID of the zone in which this address is located.
     * @type {string}
     * @memberof CustomerAddress
     */
    'zoneId'?: string;
    /**
     * The building number or apartment number of the address.
     * @type {string}
     * @memberof CustomerAddress
     */
    'buildingNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerAddress
     */
    'isActive'?: boolean;
}

export const CustomerAddressTypeEnum = {
    Home: 'home',
    Office: 'office',
    School: 'school',
    Other: 'other'
} as const;

export type CustomerAddressTypeEnum = typeof CustomerAddressTypeEnum[keyof typeof CustomerAddressTypeEnum];

/**
 * 
 * @export
 * @interface CustomerOrderViewDTO
 */
export interface CustomerOrderViewDTO {
    /**
     * Status of the order.
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'status'?: CustomerOrderViewDTOStatusEnum;
    /**
     * The customer\'s rating for the order (1-5 scale).
     * @type {number}
     * @memberof CustomerOrderViewDTO
     */
    'customerRating'?: number;
    /**
     * The customer\'s review or feedback for the order.
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'customerReview'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'expectedDeliveryTimeFormatted': string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerOrderViewDTO
     */
    'isPickup': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerOrderViewDTO
     */
    'completedReview': boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'outletId': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'orderFriendlyId': string;
    /**
     * The PIN associated with the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'pin': string;
    /**
     * The name of the vendor
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'vendorName': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'orderType': CustomerOrderViewDTOOrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'recipientName': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerOrderViewDTO
     */
    'isGift': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerOrderViewDTO
     */
    'isScheduled': boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'scheduledTime': string;
    /**
     * The name of the outlet
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'outletName': string;
    /**
     * Outlet contact phone
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'outletPhone': string;
    /**
     * The logo of the vendor
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'vendorLogo': string;
    /**
     * The delivery address for the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'deliveryAddress': string;
    /**
     * The address of the outlet
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'outletAddress': string;
    /**
     * The items in the order
     * @type {Array<OrderItem>}
     * @memberof CustomerOrderViewDTO
     */
    'items': Array<OrderItem>;
    /**
     * The method of payment for the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'paymentMethod': string;
    /**
     * Any discount applied to the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'discount': string;
    /**
     * Service fee for the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'serviceFee': string;
    /**
     * Delivery fee for the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'deliveryFee': string;
    /**
     * The subtotal of the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'subTotal': string;
    /**
     * The total amount for the order
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'total': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'approvedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'declinedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'canceledAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'completedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'processingAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'shippedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'deliveredAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'readyForPickupAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'returnedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'refundedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerOrderViewDTO
     */
    'arrivedAt': string;
}

export const CustomerOrderViewDTOStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Declined: 'declined',
    Processing: 'processing',
    ReadyForPickup: 'ready-for-pickup',
    Shipped: 'shipped',
    OrderArrived: 'order-arrived',
    OrderFulfilled: 'order-fulfilled',
    Returned: 'returned',
    ReturnRequested: 'return-requested',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type CustomerOrderViewDTOStatusEnum = typeof CustomerOrderViewDTOStatusEnum[keyof typeof CustomerOrderViewDTOStatusEnum];
export const CustomerOrderViewDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup'
} as const;

export type CustomerOrderViewDTOOrderTypeEnum = typeof CustomerOrderViewDTOOrderTypeEnum[keyof typeof CustomerOrderViewDTOOrderTypeEnum];

/**
 * 
 * @export
 * @interface DaysOfWork
 */
export interface DaysOfWork {
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'monday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'tuesday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'wednesday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'thursday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'friday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'saturday': OpeningHours;
    /**
     * 
     * @type {OpeningHours}
     * @memberof DaysOfWork
     */
    'sunday': OpeningHours;
}
/**
 * 
 * @export
 * @interface FormattedCart
 */
export interface FormattedCart {
    /**
     * List of items in the cart
     * @type {Array<CartItem>}
     * @memberof FormattedCart
     */
    'items': Array<CartItem>;
    /**
     * Total price for the cart items
     * @type {number}
     * @memberof FormattedCart
     */
    'total': number;
    /**
     * Name of the outlet
     * @type {string}
     * @memberof FormattedCart
     */
    'outletName': string;
    /**
     * Logo URL of the vendor
     * @type {string}
     * @memberof FormattedCart
     */
    'vendorLogo': string;
    /**
     * 
     * @type {string}
     * @memberof FormattedCart
     */
    'outletId': string;
}
/**
 * 
 * @export
 * @interface GlobalTaxonomy
 */
export interface GlobalTaxonomy {
    /**
     * Unique identifier for the vendor, automatically generated by MongoDB.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'id': string;
    /**
     * Name of the global category or market type.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'name': string;
    /**
     * The kebab-case version of the category name for URL paths.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'handle'?: string;
    /**
     * Optional description providing more details about the category or market type.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'description'?: string;
    /**
     * The ID of the parent category, if this category is a subcategory.
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'parentCategoryId'?: string;
    /**
     * The type of category (product_category or market_type).
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'categoryType': GlobalTaxonomyCategoryTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof GlobalTaxonomy
     */
    'tags': Array<string>;
    /**
     * URL or path to an image representing the category or market type (e.g., a logo or icon).
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'emojiText'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalTaxonomy
     */
    'coverImageUrl'?: string;
}

export const GlobalTaxonomyCategoryTypeEnum = {
    ProductCategory: 'product-category',
    MarketType: 'market-type'
} as const;

export type GlobalTaxonomyCategoryTypeEnum = typeof GlobalTaxonomyCategoryTypeEnum[keyof typeof GlobalTaxonomyCategoryTypeEnum];

/**
 * 
 * @export
 * @interface GroupedSearchProductResponseDto
 */
export interface GroupedSearchProductResponseDto {
    /**
     * 
     * @type {Array<GroupedSearchProductResponseDtoData>}
     * @memberof GroupedSearchProductResponseDto
     */
    'data': Array<GroupedSearchProductResponseDtoData>;
}
/**
 * 
 * @export
 * @interface GroupedSearchProductResponseDtoData
 */
export interface GroupedSearchProductResponseDtoData {
    /**
     * 
     * @type {number}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'ratingsFive': number;
    /**
     * 
     * @type {number}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'ratingsFour': number;
    /**
     * 
     * @type {number}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'ratingsThree': number;
    /**
     * 
     * @type {number}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'ratingsTwo': number;
    /**
     * 
     * @type {number}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'ratingsOne': number;
    /**
     * 
     * @type {number}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'averageRating': number;
    /**
     * 
     * @type {string}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'caption'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'outletId'?: string;
    /**
     * 
     * @type {OperationsToday}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'operationsToday'?: OperationsToday;
    /**
     * 
     * @type {Array<ProductSearchResult>}
     * @memberof GroupedSearchProductResponseDtoData
     */
    'products'?: Array<ProductSearchResult>;
}
/**
 * 
 * @export
 * @interface LeanVendorDetail
 */
export interface LeanVendorDetail {
    /**
     * 
     * @type {string}
     * @memberof LeanVendorDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeanVendorDetail
     */
    'vendorName': string;
    /**
     * 
     * @type {string}
     * @memberof LeanVendorDetail
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof LeanVendorDetail
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof LeanVendorDetail
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof LeanVendorDetail
     */
    'verificationStatus': string;
    /**
     * 
     * @type {string}
     * @memberof LeanVendorDetail
     */
    'coverPhoto': string;
}
/**
 * 
 * @export
 * @interface MarketplaceOutletInventory
 */
export interface MarketplaceOutletInventory {
    /**
     * 
     * @type {Array<Product>}
     * @memberof MarketplaceOutletInventory
     */
    'products': Array<Product>;
    /**
     * 
     * @type {Array<Category>}
     * @memberof MarketplaceOutletInventory
     */
    'categories': Array<Category>;
}
/**
 * 
 * @export
 * @interface MarketplaceProductListing
 */
export interface MarketplaceProductListing {
    /**
     * Unique identifier for the product, automatically generated by MongoDB.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'id': string;
    /**
     * Unique identifier for the outlet where the product is sold.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'outletId': string;
    /**
     * URL to the product image.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'photo'?: string;
    /**
     * Old photo of the product.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'oldPhoto'?: string;
    /**
     * Date when the product was migrated.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'migratedAt'?: string;
    /**
     * Name of the product.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'name': string;
    /**
     * Array of category IDs to which the product belongs.
     * @type {Array<string>}
     * @memberof MarketplaceProductListing
     */
    'categoryIds'?: Array<string>;
    /**
     * Short description of the product.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'description'?: string;
    /**
     * Price of the product.
     * @type {number}
     * @memberof MarketplaceProductListing
     */
    'amount': number;
    /**
     * Indicates if the product is featured.
     * @type {boolean}
     * @memberof MarketplaceProductListing
     */
    'isFeatured'?: boolean;
    /**
     * Indicates if the product is active and available for purchase.
     * @type {boolean}
     * @memberof MarketplaceProductListing
     */
    'isActive'?: boolean;
    /**
     * Keywords associated with the product.
     * @type {Array<string>}
     * @memberof MarketplaceProductListing
     */
    'tags'?: Array<string>;
    /**
     * Current availability status of the product.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'availability': MarketplaceProductListingAvailabilityEnum;
    /**
     * Array of addons for this item
     * @type {Array<string>}
     * @memberof MarketplaceProductListing
     */
    'addonGroupIds'?: Array<string>;
    /**
     * Global Tukshopp category to which the product belongs. Helps in making products searchable globally.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'GTSCategoryId'?: string;
    /**
     * Global Tukshopp Product Template ID. Helps in making products searchable globally.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'GTSProductTemplateId'?: string;
    /**
     * Order of the product in the outlet.
     * @type {number}
     * @memberof MarketplaceProductListing
     */
    'order'?: number;
    /**
     * Timestamp when the product was created.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'createdAt': string;
    /**
     * Timestamp when the product was last updated.
     * @type {string}
     * @memberof MarketplaceProductListing
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<AddonGroup>}
     * @memberof MarketplaceProductListing
     */
    'addonGroups': Array<AddonGroup>;
}

export const MarketplaceProductListingAvailabilityEnum = {
    InStock: 'in-stock',
    OutOfStock: 'out-of-stock'
} as const;

export type MarketplaceProductListingAvailabilityEnum = typeof MarketplaceProductListingAvailabilityEnum[keyof typeof MarketplaceProductListingAvailabilityEnum];

/**
 * 
 * @export
 * @interface NewOrderIntentDTO
 */
export interface NewOrderIntentDTO {
    /**
     * Unique identifier for the outlet where the order is placed.
     * @type {string}
     * @memberof NewOrderIntentDTO
     */
    'outletId'?: string;
    /**
     * The delivery address for the order (if orderType is \"delivery\").
     * @type {CustomerAddress}
     * @memberof NewOrderIntentDTO
     */
    'deliveryAddress': CustomerAddress;
    /**
     * List of items included in the order.
     * @type {Array<OrderItem>}
     * @memberof NewOrderIntentDTO
     */
    'items': Array<OrderItem>;
}
/**
 * 
 * @export
 * @interface OpeningHours
 */
export interface OpeningHours {
    /**
     * Opening time (e.g., 09:00)
     * @type {string}
     * @memberof OpeningHours
     */
    'open': string;
    /**
     * Closing time (e.g., 17:00)
     * @type {string}
     * @memberof OpeningHours
     */
    'close': string;
    /**
     * Indicates if the outlet is always open
     * @type {boolean}
     * @memberof OpeningHours
     */
    'alwaysOpen': boolean;
    /**
     * Indicates if the outlet is always open
     * @type {boolean}
     * @memberof OpeningHours
     */
    'closed'?: boolean;
}
/**
 * 
 * @export
 * @interface OperationsToday
 */
export interface OperationsToday {
    /**
     * 
     * @type {boolean}
     * @memberof OperationsToday
     */
    'isOpenNow': boolean;
    /**
     * 
     * @type {string}
     * @memberof OperationsToday
     */
    'closesAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof OperationsToday
     */
    'alwaysOpen': boolean;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Unique identifier for the order, automatically generated by MongoDB.
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * Unique identifier for the vendor associated with the order.
     * @type {string}
     * @memberof Order
     */
    'vendorId'?: string;
    /**
     * Unique identifier for the outlet where the order is placed.
     * @type {string}
     * @memberof Order
     */
    'outletId'?: string;
    /**
     * Unique identifier for the customer who placed the order.
     * @type {string}
     * @memberof Order
     */
    'customerId'?: string;
    /**
     * Unique identifier for the zone where the order is delivered.
     * @type {string}
     * @memberof Order
     */
    'zoneId'?: string;
    /**
     * List of items included in the order.
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    'items': Array<OrderItem>;
    /**
     * Discount amount the order.
     * @type {number}
     * @memberof Order
     */
    'discountAmount'?: number;
    /**
     * Giftcard amount the order.
     * @type {number}
     * @memberof Order
     */
    'giftCardAmount'?: number;
    /**
     * Promo code the order.
     * @type {string}
     * @memberof Order
     */
    'promoCode'?: string;
    /**
     * Promo amount the order.
     * @type {number}
     * @memberof Order
     */
    'promoAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'giftCardCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'discountCode'?: string;
    /**
     * Total price of the order.
     * @type {number}
     * @memberof Order
     */
    'totalPrice': number;
    /**
     * Due amount
     * @type {number}
     * @memberof Order
     */
    'amountDue': number;
    /**
     * Total price of the order.
     * @type {number}
     * @memberof Order
     */
    'subTotal': number;
    /**
     * Status of the order.
     * @type {string}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'refundStatus'?: OrderRefundStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'refundType'?: OrderRefundTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'refundAmount'?: number;
    /**
     * Delivery instructions
     * @type {string}
     * @memberof Order
     */
    'deliveryInstructions'?: string;
    /**
     * The type of order (delivery or pickup).
     * @type {string}
     * @memberof Order
     */
    'orderType': OrderOrderTypeEnum;
    /**
     * The payment method used for the order.
     * @type {string}
     * @memberof Order
     */
    'paymentMethod'?: OrderPaymentMethodEnum;
    /**
     * The status of the payment for the order.
     * @type {string}
     * @memberof Order
     */
    'paymentStatus'?: OrderPaymentStatusEnum;
    /**
     * Pin to confirm order delivery
     * @type {string}
     * @memberof Order
     */
    'confirmationPin': string;
    /**
     * Pin to confirm order delivery
     * @type {string}
     * @memberof Order
     */
    'confirmationPinPlain': string;
    /**
     * The transaction ID from the payment gateway (if applicable).
     * @type {string}
     * @memberof Order
     */
    'transactionId'?: string;
    /**
     * The type of entity the transaction is associated with
     * @type {string}
     * @memberof Order
     */
    'transactionEntityType'?: OrderTransactionEntityTypeEnum;
    /**
     * Any special notes or instructions provided by the customer for the order.
     * @type {string}
     * @memberof Order
     */
    'customerNotes'?: string;
    /**
     * The reason for cancellation if the order is cancelled.
     * @type {string}
     * @memberof Order
     */
    'cancellationReason'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'canceledBy'?: OrderCanceledByEnum;
    /**
     * The delivery address for the order (if orderType is \"delivery\").
     * @type {CustomerAddress}
     * @memberof Order
     */
    'deliveryAddress': CustomerAddress;
    /**
     * Pickup address
     * @type {OutletAddress}
     * @memberof Order
     */
    'pickupAddress': OutletAddress;
    /**
     * The delivery fee for the order (if applicable).
     * @type {number}
     * @memberof Order
     */
    'deliveryFee'?: number;
    /**
     * 
     * @type {OrderRecipient}
     * @memberof Order
     */
    'recipient': OrderRecipient;
    /**
     * Platform fee charged to the customer for this order.
     * @type {number}
     * @memberof Order
     */
    'platformFee'?: number;
    /**
     * Commission fee charged to the vendor for this order.
     * @type {number}
     * @memberof Order
     */
    'commissionFee'?: number;
    /**
     * Final payout amount to the vendor after deducting commission.
     * @type {number}
     * @memberof Order
     */
    'payoutAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'riderPayoutAmount'?: number;
    /**
     * Status of the platform fee payout for this order.
     * @type {string}
     * @memberof Order
     */
    'payoutStatus'?: OrderPayoutStatusEnum;
    /**
     * The ID of the driver assigned to deliver the order (if applicable).
     * @type {string}
     * @memberof Order
     */
    'assignedDriverId'?: string;
    /**
     * The tracking number for the order (if applicable).
     * @type {string}
     * @memberof Order
     */
    'trackingNumber'?: string;
    /**
     * The customer\'s rating for the order (1-5 scale).
     * @type {number}
     * @memberof Order
     */
    'customerRating'?: number;
    /**
     * The customer\'s review or feedback for the order.
     * @type {string}
     * @memberof Order
     */
    'customerReview'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'expectedDeliveryTimeFormatted': string;
    /**
     * The customer\'s preferred or expected delivery time.
     * @type {string}
     * @memberof Order
     */
    'expectedDeliveryTime'?: string;
    /**
     * The customer\'s scheduled delivery time.
     * @type {string}
     * @memberof Order
     */
    'scheduledDeliveryTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'isScheduled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'isGift'?: boolean;
    /**
     * Unique identifier for the payout associated with the order.
     * @type {object}
     * @memberof Order
     */
    'payoutId'?: object;
    /**
     * Unique identifier for the rider payout associated with the order.
     * @type {string}
     * @memberof Order
     */
    'riderPayoutId'?: string;
    /**
     * 
     * @type {OrderMeta}
     * @memberof Order
     */
    'orderMeta': OrderMeta;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'arrivedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'approvedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'declinedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'canceledAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'completedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'processingAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'shippedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'deliveredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'readyForPickupAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'returnedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'refundedAt'?: string;
    /**
     * Timestamp when the order was created.
     * @type {string}
     * @memberof Order
     */
    'createdAt'?: string;
    /**
     * Timestamp when the order was last updated.
     * @type {string}
     * @memberof Order
     */
    'updatedAt'?: string;
}

export const OrderStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Declined: 'declined',
    Processing: 'processing',
    ReadyForPickup: 'ready-for-pickup',
    Shipped: 'shipped',
    OrderArrived: 'order-arrived',
    OrderFulfilled: 'order-fulfilled',
    Returned: 'returned',
    ReturnRequested: 'return-requested',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];
export const OrderRefundStatusEnum = {
    None: 'none',
    Pending: 'pending',
    Completed: 'completed'
} as const;

export type OrderRefundStatusEnum = typeof OrderRefundStatusEnum[keyof typeof OrderRefundStatusEnum];
export const OrderRefundTypeEnum = {
    Full: 'full',
    Partial: 'partial'
} as const;

export type OrderRefundTypeEnum = typeof OrderRefundTypeEnum[keyof typeof OrderRefundTypeEnum];
export const OrderOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup'
} as const;

export type OrderOrderTypeEnum = typeof OrderOrderTypeEnum[keyof typeof OrderOrderTypeEnum];
export const OrderPaymentMethodEnum = {
    Wallet: 'wallet',
    Paystack: 'paystack',
    Card: 'card',
    PayForMe: 'pay-for-me'
} as const;

export type OrderPaymentMethodEnum = typeof OrderPaymentMethodEnum[keyof typeof OrderPaymentMethodEnum];
export const OrderPaymentStatusEnum = {
    Pending: 'pending',
    Paid: 'paid'
} as const;

export type OrderPaymentStatusEnum = typeof OrderPaymentStatusEnum[keyof typeof OrderPaymentStatusEnum];
export const OrderTransactionEntityTypeEnum = {
    Account: 'account',
    Vendor: 'vendor',
    Outlet: 'outlet',
    Product: 'product',
    InventoryCategory: 'inventory_category',
    Order: 'order',
    Payout: 'payout',
    Wallet: 'wallet',
    GiftCard: 'gift-card',
    ThirdPartyTransaction: 'third-party-transaction',
    WalletTransaction: 'wallet-transaction'
} as const;

export type OrderTransactionEntityTypeEnum = typeof OrderTransactionEntityTypeEnum[keyof typeof OrderTransactionEntityTypeEnum];
export const OrderCanceledByEnum = {
    Vendor: 'vendor',
    Admin: 'admin',
    Customer: 'customer'
} as const;

export type OrderCanceledByEnum = typeof OrderCanceledByEnum[keyof typeof OrderCanceledByEnum];
export const OrderPayoutStatusEnum = {
    Pending: 'pending',
    Initialized: 'initialized',
    Processing: 'processing',
    Completed: 'completed'
} as const;

export type OrderPayoutStatusEnum = typeof OrderPayoutStatusEnum[keyof typeof OrderPayoutStatusEnum];

/**
 * 
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'productName': string;
    /**
     * 
     * @type {string}
     * @memberof OrderItem
     */
    'productImage': string;
    /**
     * Unique identifier for the product included in the order.
     * @type {object}
     * @memberof OrderItem
     */
    'productId': object;
    /**
     * Quantity of the product ordered.
     * @type {number}
     * @memberof OrderItem
     */
    'quantity': number;
    /**
     * Price of a single unit of the product.
     * @type {number}
     * @memberof OrderItem
     */
    'price': number;
    /**
     * List of addons associated with this item.
     * @type {Array<CartAddon>}
     * @memberof OrderItem
     */
    'addons': Array<CartAddon>;
}
/**
 * 
 * @export
 * @interface OrderMeta
 */
export interface OrderMeta {
    /**
     * 
     * @type {number}
     * @memberof OrderMeta
     */
    'zoneComputedAverageDeliveryTimeInMins'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderMeta
     */
    'outletAveragePreparationTimeInMins'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'riderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'riderPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'riderPhoto'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'riderEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'customerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'customerPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'customerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'vendorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'outletName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'vendorPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'vendorEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderMeta
     */
    'vendorLogo'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderMeta
     */
    'outletLongitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderMeta
     */
    'outletLatitude'?: number;
}
/**
 * 
 * @export
 * @interface OrderPreview
 */
export interface OrderPreview {
    /**
     * The delivery address for the order (if orderType is \"delivery\").
     * @type {CustomerAddress}
     * @memberof OrderPreview
     */
    'deliveryAddress': CustomerAddress;
    /**
     * 
     * @type {string}
     * @memberof OrderPreview
     */
    'averageDeliveryTimeWithinZoneDesc': string;
    /**
     * 
     * @type {Array<OutletAvailableDate>}
     * @memberof OrderPreview
     */
    'availableDates': Array<OutletAvailableDate>;
    /**
     * Subtotal amount for the order
     * @type {number}
     * @memberof OrderPreview
     */
    'subTotal': number;
    /**
     * Delivery fee for the order
     * @type {number}
     * @memberof OrderPreview
     */
    'deliveryFee': number;
    /**
     * ID of the vendor
     * @type {string}
     * @memberof OrderPreview
     */
    'vendorId': string;
    /**
     * ID of the outlet
     * @type {string}
     * @memberof OrderPreview
     */
    'outletId': string;
    /**
     * ID of the zone
     * @type {string}
     * @memberof OrderPreview
     */
    'zoneId': string;
    /**
     * Name of the zone
     * @type {string}
     * @memberof OrderPreview
     */
    'zoneName': string;
    /**
     * Address of the outlet
     * @type {string}
     * @memberof OrderPreview
     */
    'outletAddress': string;
    /**
     * 
     * @type {number}
     * @memberof OrderPreview
     */
    'outletLongitude': number;
    /**
     * 
     * @type {number}
     * @memberof OrderPreview
     */
    'outletLatitude': number;
    /**
     * Name of the outlet
     * @type {string}
     * @memberof OrderPreview
     */
    'outletName': string;
    /**
     * Name of the vendor
     * @type {string}
     * @memberof OrderPreview
     */
    'vendorName': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPreview
     */
    'vendorLogo': string;
    /**
     * ID of the customer
     * @type {string}
     * @memberof OrderPreview
     */
    'customerId': string;
    /**
     * Name of the customer
     * @type {string}
     * @memberof OrderPreview
     */
    'customerName': string;
    /**
     * Service fee charged by the platform
     * @type {number}
     * @memberof OrderPreview
     */
    'serviceFeeFlat': number;
    /**
     * Service fee per
     * @type {number}
     * @memberof OrderPreview
     */
    'serviceFeePercentage': number;
    /**
     * Discount amount applicable
     * @type {number}
     * @memberof OrderPreview
     */
    'discountAmount': number;
    /**
     * Indicates if pay on delivery is supported
     * @type {boolean}
     * @memberof OrderPreview
     */
    'supportsPayOnDelivery': boolean;
    /**
     * Indicates if scheduled delivery is supported
     * @type {boolean}
     * @memberof OrderPreview
     */
    'supportsScheduledDelivery': boolean;
    /**
     * List of order items
     * @type {Array<OrderItem>}
     * @memberof OrderPreview
     */
    'items': Array<OrderItem>;
    /**
     * Hash of the payload for integrity validation
     * @type {string}
     * @memberof OrderPreview
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface OrderRecipient
 */
export interface OrderRecipient {
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'landmark'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'buildingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'senderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'customerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'customerPhone'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'customerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecipient
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface Outlet
 */
export interface Outlet {
    /**
     * Unique identifier for the outlet, automatically generated by MongoDB.
     * @type {string}
     * @memberof Outlet
     */
    'id': string;
    /**
     * 
     * @type {OverviewMeta}
     * @memberof Outlet
     */
    'overviewMeta'?: OverviewMeta;
    /**
     * Unique identifier for the vendor associated with this outlet.
     * @type {string}
     * @memberof Outlet
     */
    'vendorId': string;
    /**
     * Name of the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'outletName'?: string;
    /**
     * Preferred display name for the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'preferredOutletDisplayName'?: string;
    /**
     * Enable preferred display name for the outlet.
     * @type {boolean}
     * @memberof Outlet
     */
    'enablePreferredOutletDisplayName'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Outlet
     */
    'coverPhoto'?: string;
    /**
     * Old photo of the product.
     * @type {string}
     * @memberof Outlet
     */
    'oldPhoto'?: string;
    /**
     * Date when the product was migrated.
     * @type {string}
     * @memberof Outlet
     */
    'migratedAt'?: string;
    /**
     * Caption or tagline for the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'caption'?: string;
    /**
     * Market segments that the outlet serves.
     * @type {Array<string>}
     * @memberof Outlet
     */
    'marketSegments'?: Array<string>;
    /**
     * Market segment that the outlet serves.
     * @type {string}
     * @memberof Outlet
     */
    'primaryMarketSegment'?: string;
    /**
     * Unique identifier for the zone where the outlet is located.
     * @type {string}
     * @memberof Outlet
     */
    'zoneId'?: string;
    /**
     * Address details of the outlet.
     * @type {OutletAddress}
     * @memberof Outlet
     */
    'address'?: OutletAddress;
    /**
     * Timestamp when the outlet address was last updated
     * @type {string}
     * @memberof Outlet
     */
    'addressLastUpdated'?: string;
    /**
     * Configuration settings for the outlet.
     * @type {OutletConfig}
     * @memberof Outlet
     */
    'config'?: OutletConfig;
    /**
     * Verification status of the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'verificationStatus'?: OutletVerificationStatusEnum;
    /**
     * Current status of the outlet.
     * @type {string}
     * @memberof Outlet
     */
    'status'?: OutletStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'ratingsFive': number;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'ratingsFour': number;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'ratingsThree': number;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'ratingsTwo': number;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'ratingsOne': number;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'averageRating': number;
    /**
     * 
     * @type {boolean}
     * @memberof Outlet
     */
    'requiresVerification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Outlet
     */
    'IsFeatured'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Outlet
     */
    'IsRecommended'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Outlet
     */
    'IsBestSeller'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Outlet
     */
    'IsPromoted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'ranking'?: number;
    /**
     * 
     * @type {OperationsToday}
     * @memberof Outlet
     */
    'operationsToday': OperationsToday;
    /**
     * Contact email for the vendor.
     * @type {string}
     * @memberof Outlet
     */
    'contactEmail'?: string;
    /**
     * Contact phone number for the vendor.
     * @type {string}
     * @memberof Outlet
     */
    'contactPhone'?: string;
    /**
     * Alternate contact phone number for the vendor.
     * @type {string}
     * @memberof Outlet
     */
    'alternateContactPhone'?: string;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'averageAcceptTimeInMins'?: number;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'averagePreparationTimeInMins'?: number;
    /**
     * 
     * @type {number}
     * @memberof Outlet
     */
    'averageTimeToShipInMins'?: number;
    /**
     * 
     * @type {string}
     * @memberof Outlet
     */
    'averageAcceptTimeInMinsFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof Outlet
     */
    'averagePreparationTimeInMinsFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof Outlet
     */
    'averageTimeToShipInMinsFormatted'?: string;
    /**
     * Timestamp when the outlet document was created.
     * @type {string}
     * @memberof Outlet
     */
    'createdAt'?: string;
    /**
     * Timestamp when the outlet document was last updated.
     * @type {string}
     * @memberof Outlet
     */
    'updatedAt'?: string;
}

export const OutletVerificationStatusEnum = {
    Pending: 'pending',
    Approved: 'approved'
} as const;

export type OutletVerificationStatusEnum = typeof OutletVerificationStatusEnum[keyof typeof OutletVerificationStatusEnum];
export const OutletStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Disabled: 'disabled'
} as const;

export type OutletStatusEnum = typeof OutletStatusEnum[keyof typeof OutletStatusEnum];

/**
 * 
 * @export
 * @interface OutletAddress
 */
export interface OutletAddress {
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof OutletAddress
     */
    'country'?: string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof OutletAddress
     */
    'countryCode'?: string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof OutletAddress
     */
    'state'?: string;
    /**
     * State or region code within the country where the zone is located.
     * @type {string}
     * @memberof OutletAddress
     */
    'stateCode'?: string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof OutletAddress
     */
    'address'?: string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof OutletAddress
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof OutletAddress
     */
    'longitude'?: number;
    /**
     * Additional notes or instructions for the address
     * @type {string}
     * @memberof OutletAddress
     */
    'notes'?: string;
    /**
     * The type or category of the address.
     * @type {string}
     * @memberof OutletAddress
     */
    'type'?: OutletAddressTypeEnum;
    /**
     * A nearby landmark or easily recognizable location near the address.
     * @type {string}
     * @memberof OutletAddress
     */
    'landmark'?: string;
    /**
     * The ID of the zone in which this address is located.
     * @type {string}
     * @memberof OutletAddress
     */
    'zoneId'?: string;
    /**
     * The building number or apartment number of the address.
     * @type {string}
     * @memberof OutletAddress
     */
    'buildingNumber'?: string;
    /**
     * Friendly address used for naming outlet
     * @type {string}
     * @memberof OutletAddress
     */
    'friendlyAddress'?: string;
}

export const OutletAddressTypeEnum = {
    Home: 'home',
    Office: 'office',
    School: 'school',
    Other: 'other'
} as const;

export type OutletAddressTypeEnum = typeof OutletAddressTypeEnum[keyof typeof OutletAddressTypeEnum];

/**
 * 
 * @export
 * @interface OutletAvailableDate
 */
export interface OutletAvailableDate {
    /**
     * 
     * @type {string}
     * @memberof OutletAvailableDate
     */
    'day': string;
    /**
     * 
     * @type {string}
     * @memberof OutletAvailableDate
     */
    'dayDateFormatted': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OutletAvailableDate
     */
    'slots': Array<string>;
}
/**
 * 
 * @export
 * @interface OutletConfig
 */
export interface OutletConfig {
    /**
     * Automatically accept orders
     * @type {boolean}
     * @memberof OutletConfig
     */
    'autoAcceptOrders'?: boolean;
    /**
     * Allow customers to pick up orders at the outlet
     * @type {boolean}
     * @memberof OutletConfig
     */
    'allowPickupAtOutlet'?: boolean;
    /**
     * Allow customers to schedule order
     * @type {boolean}
     * @memberof OutletConfig
     */
    'allowScheduling'?: boolean;
    /**
     * Enable or disable notifications for new orders
     * @type {boolean}
     * @memberof OutletConfig
     */
    'enableOrderNotifications'?: boolean;
    /**
     * Minimum order amount for delivery
     * @type {number}
     * @memberof OutletConfig
     */
    'minimumOrderAmount'?: number;
    /**
     * Maximum number of orders to accept simultaneously
     * @type {number}
     * @memberof OutletConfig
     */
    'maxConcurrentOrders'?: number;
    /**
     * Allow or disallow cash on delivery
     * @type {boolean}
     * @memberof OutletConfig
     */
    'allowCashOnDelivery'?: boolean;
    /**
     * Contact email for vendor support
     * @type {string}
     * @memberof OutletConfig
     */
    'supportContactEmail'?: string;
    /**
     * Contact phone number for vendor support
     * @type {string}
     * @memberof OutletConfig
     */
    'supportContactPhone'?: string;
    /**
     * 
     * @type {DaysOfWork}
     * @memberof OutletConfig
     */
    'daysOfWork': DaysOfWork;
    /**
     * Reason for temporary closure
     * @type {string}
     * @memberof OutletConfig
     */
    'closureReason'?: string;
    /**
     * Indicates if the outlet is currently closed
     * @type {boolean}
     * @memberof OutletConfig
     */
    'isClosed'?: boolean;
    /**
     * Indicates wheather a newly placed order requires action accept/decline to continue
     * @type {boolean}
     * @memberof OutletConfig
     */
    'newOrderRequiresAction'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OutletConfig
     */
    'acceptingOrders'?: boolean;
}
/**
 * 
 * @export
 * @interface OutletMarketplaceDetail
 */
export interface OutletMarketplaceDetail {
    /**
     * Unique identifier for the outlet, automatically generated by MongoDB.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'id': string;
    /**
     * 
     * @type {OverviewMeta}
     * @memberof OutletMarketplaceDetail
     */
    'overviewMeta'?: OverviewMeta;
    /**
     * Unique identifier for the vendor associated with this outlet.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'vendorId': string;
    /**
     * Name of the outlet.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'outletName'?: string;
    /**
     * Preferred display name for the outlet.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'preferredOutletDisplayName'?: string;
    /**
     * Enable preferred display name for the outlet.
     * @type {boolean}
     * @memberof OutletMarketplaceDetail
     */
    'enablePreferredOutletDisplayName'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'coverPhoto'?: string;
    /**
     * Old photo of the product.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'oldPhoto'?: string;
    /**
     * Date when the product was migrated.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'migratedAt'?: string;
    /**
     * Caption or tagline for the outlet.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'caption'?: string;
    /**
     * Market segments that the outlet serves.
     * @type {Array<string>}
     * @memberof OutletMarketplaceDetail
     */
    'marketSegments'?: Array<string>;
    /**
     * Market segment that the outlet serves.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'primaryMarketSegment'?: string;
    /**
     * Unique identifier for the zone where the outlet is located.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'zoneId'?: string;
    /**
     * Address details of the outlet.
     * @type {OutletAddress}
     * @memberof OutletMarketplaceDetail
     */
    'address'?: OutletAddress;
    /**
     * Timestamp when the outlet address was last updated
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'addressLastUpdated'?: string;
    /**
     * Configuration settings for the outlet.
     * @type {OutletConfig}
     * @memberof OutletMarketplaceDetail
     */
    'config'?: OutletConfig;
    /**
     * Verification status of the outlet.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'verificationStatus'?: OutletMarketplaceDetailVerificationStatusEnum;
    /**
     * Current status of the outlet.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'status'?: OutletMarketplaceDetailStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'ratingsFive': number;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'ratingsFour': number;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'ratingsThree': number;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'ratingsTwo': number;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'ratingsOne': number;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'averageRating': number;
    /**
     * 
     * @type {boolean}
     * @memberof OutletMarketplaceDetail
     */
    'requiresVerification': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OutletMarketplaceDetail
     */
    'IsFeatured'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OutletMarketplaceDetail
     */
    'IsRecommended'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OutletMarketplaceDetail
     */
    'IsBestSeller'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OutletMarketplaceDetail
     */
    'IsPromoted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'ranking'?: number;
    /**
     * 
     * @type {OperationsToday}
     * @memberof OutletMarketplaceDetail
     */
    'operationsToday': OperationsToday;
    /**
     * Contact email for the vendor.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'contactEmail'?: string;
    /**
     * Contact phone number for the vendor.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'contactPhone'?: string;
    /**
     * Alternate contact phone number for the vendor.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'alternateContactPhone'?: string;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'averageAcceptTimeInMins'?: number;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'averagePreparationTimeInMins'?: number;
    /**
     * 
     * @type {number}
     * @memberof OutletMarketplaceDetail
     */
    'averageTimeToShipInMins'?: number;
    /**
     * 
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'averageAcceptTimeInMinsFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'averagePreparationTimeInMinsFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'averageTimeToShipInMinsFormatted'?: string;
    /**
     * Timestamp when the outlet document was created.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'createdAt'?: string;
    /**
     * Timestamp when the outlet document was last updated.
     * @type {string}
     * @memberof OutletMarketplaceDetail
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {LeanVendorDetail}
     * @memberof OutletMarketplaceDetail
     */
    'vendor': LeanVendorDetail;
}

export const OutletMarketplaceDetailVerificationStatusEnum = {
    Pending: 'pending',
    Approved: 'approved'
} as const;

export type OutletMarketplaceDetailVerificationStatusEnum = typeof OutletMarketplaceDetailVerificationStatusEnum[keyof typeof OutletMarketplaceDetailVerificationStatusEnum];
export const OutletMarketplaceDetailStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Disabled: 'disabled'
} as const;

export type OutletMarketplaceDetailStatusEnum = typeof OutletMarketplaceDetailStatusEnum[keyof typeof OutletMarketplaceDetailStatusEnum];

/**
 * 
 * @export
 * @interface OverviewMeta
 */
export interface OverviewMeta {
    /**
     * 
     * @type {number}
     * @memberof OverviewMeta
     */
    'totalOrders': number;
    /**
     * 
     * @type {number}
     * @memberof OverviewMeta
     */
    'members': number;
}
/**
 * 
 * @export
 * @interface PaginatedOrderResponseDto
 */
export interface PaginatedOrderResponseDto {
    /**
     * The paginated data (array of items).
     * @type {Array<Order>}
     * @memberof PaginatedOrderResponseDto
     */
    'data': Array<Order>;
    /**
     * The total number of items matching the query.
     * @type {number}
     * @memberof PaginatedOrderResponseDto
     */
    'total': number;
    /**
     * The current page number.
     * @type {number}
     * @memberof PaginatedOrderResponseDto
     */
    'currentPage': number;
    /**
     * Indicates if there is a next page of results.
     * @type {boolean}
     * @memberof PaginatedOrderResponseDto
     */
    'hasNextPage': boolean;
    /**
     * Indicates if there is a previous page of results.
     * @type {boolean}
     * @memberof PaginatedOrderResponseDto
     */
    'hasPreviousPage': boolean;
}
/**
 * 
 * @export
 * @interface PaystackTransactionIntent
 */
export interface PaystackTransactionIntent {
    /**
     * Indicates whether the transaction initialization was successful.
     * @type {boolean}
     * @memberof PaystackTransactionIntent
     */
    'success': boolean;
    /**
     * A unique reference generated by Paystack for this transaction.
     * @type {string}
     * @memberof PaystackTransactionIntent
     */
    'reference': string;
    /**
     * The URL where the user should be redirected to complete the payment authorization process. (Optional)
     * @type {string}
     * @memberof PaystackTransactionIntent
     */
    'authorizationUrl'?: string;
    /**
     * The amount involved in the transaction (in kobo).
     * @type {number}
     * @memberof PaystackTransactionIntent
     */
    'amount': number;
    /**
     * A message from Paystack about the transaction intent.
     * @type {string}
     * @memberof PaystackTransactionIntent
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PaywithCardDto
 */
export interface PaywithCardDto {
    /**
     * 
     * @type {string}
     * @memberof PaywithCardDto
     */
    'authorizationCde': string;
}
/**
 * 
 * @export
 * @interface PlaceOrderDTO
 */
export interface PlaceOrderDTO {
    /**
     * Delivery instructions
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'deliveryInstructions'?: string;
    /**
     * The type of order (delivery or pickup).
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'orderType': PlaceOrderDTOOrderTypeEnum;
    /**
     * The payment method used for the order.
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'paymentMethod'?: PlaceOrderDTOPaymentMethodEnum;
    /**
     * Any special notes or instructions provided by the customer for the order.
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'customerNotes'?: string;
    /**
     * 
     * @type {OrderRecipient}
     * @memberof PlaceOrderDTO
     */
    'recipient': OrderRecipient;
    /**
     * The customer\'s scheduled delivery time.
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'scheduledDeliveryTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceOrderDTO
     */
    'isScheduled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceOrderDTO
     */
    'isGift'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'cardAuthorization'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'promoCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'discountCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderDTO
     */
    'giftCardCode'?: string;
    /**
     * 
     * @type {OrderPreview}
     * @memberof PlaceOrderDTO
     */
    'orderPreview': OrderPreview;
}

export const PlaceOrderDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup'
} as const;

export type PlaceOrderDTOOrderTypeEnum = typeof PlaceOrderDTOOrderTypeEnum[keyof typeof PlaceOrderDTOOrderTypeEnum];
export const PlaceOrderDTOPaymentMethodEnum = {
    Wallet: 'wallet',
    Paystack: 'paystack',
    Card: 'card',
    PayForMe: 'pay-for-me'
} as const;

export type PlaceOrderDTOPaymentMethodEnum = typeof PlaceOrderDTOPaymentMethodEnum[keyof typeof PlaceOrderDTOPaymentMethodEnum];

/**
 * 
 * @export
 * @interface PriceIncreaseTimeSlot
 */
export interface PriceIncreaseTimeSlot {
    /**
     * Start hour of the price increase time slot (0-23)
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'startHour': number;
    /**
     * End hour of the price increase time slot (0-23)
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'endHour': number;
    /**
     * Type of price increase to apply
     * @type {string}
     * @memberof PriceIncreaseTimeSlot
     */
    'increaseType': PriceIncreaseTimeSlotIncreaseTypeEnum;
    /**
     * Percentage increase to apply during this time slot
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'percentageIncrease'?: number;
    /**
     * Fixed amount (in Naira) to add to the delivery fee during this time slot
     * @type {number}
     * @memberof PriceIncreaseTimeSlot
     */
    'fixedFeeIncrease'?: number;
}

export const PriceIncreaseTimeSlotIncreaseTypeEnum = {
    Percentage: 'percentage',
    FixedAmount: 'fixed_amount'
} as const;

export type PriceIncreaseTimeSlotIncreaseTypeEnum = typeof PriceIncreaseTimeSlotIncreaseTypeEnum[keyof typeof PriceIncreaseTimeSlotIncreaseTypeEnum];

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Unique identifier for the product, automatically generated by MongoDB.
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * Unique identifier for the outlet where the product is sold.
     * @type {string}
     * @memberof Product
     */
    'outletId': string;
    /**
     * URL to the product image.
     * @type {string}
     * @memberof Product
     */
    'photo'?: string;
    /**
     * Old photo of the product.
     * @type {string}
     * @memberof Product
     */
    'oldPhoto'?: string;
    /**
     * Date when the product was migrated.
     * @type {string}
     * @memberof Product
     */
    'migratedAt'?: string;
    /**
     * Name of the product.
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * Array of category IDs to which the product belongs.
     * @type {Array<string>}
     * @memberof Product
     */
    'categoryIds'?: Array<string>;
    /**
     * Short description of the product.
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * Price of the product.
     * @type {number}
     * @memberof Product
     */
    'amount': number;
    /**
     * Indicates if the product is featured.
     * @type {boolean}
     * @memberof Product
     */
    'isFeatured'?: boolean;
    /**
     * Indicates if the product is active and available for purchase.
     * @type {boolean}
     * @memberof Product
     */
    'isActive'?: boolean;
    /**
     * Keywords associated with the product.
     * @type {Array<string>}
     * @memberof Product
     */
    'tags'?: Array<string>;
    /**
     * Current availability status of the product.
     * @type {string}
     * @memberof Product
     */
    'availability': ProductAvailabilityEnum;
    /**
     * Array of addons for this item
     * @type {Array<string>}
     * @memberof Product
     */
    'addonGroupIds'?: Array<string>;
    /**
     * Global Tukshopp category to which the product belongs. Helps in making products searchable globally.
     * @type {string}
     * @memberof Product
     */
    'GTSCategoryId'?: string;
    /**
     * Global Tukshopp Product Template ID. Helps in making products searchable globally.
     * @type {string}
     * @memberof Product
     */
    'GTSProductTemplateId'?: string;
    /**
     * Order of the product in the outlet.
     * @type {number}
     * @memberof Product
     */
    'order'?: number;
    /**
     * Timestamp when the product was created.
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * Timestamp when the product was last updated.
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
}

export const ProductAvailabilityEnum = {
    InStock: 'in-stock',
    OutOfStock: 'out-of-stock'
} as const;

export type ProductAvailabilityEnum = typeof ProductAvailabilityEnum[keyof typeof ProductAvailabilityEnum];

/**
 * 
 * @export
 * @interface ProductAddon
 */
export interface ProductAddon {
    /**
     * 
     * @type {string}
     * @memberof ProductAddon
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAddon
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ProductAddon
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProductAddon
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ProductAddon
     */
    'availabilityStatus': ProductAddonAvailabilityStatusEnum;
}

export const ProductAddonAvailabilityStatusEnum = {
    InStock: 'in-stock',
    OutOfStock: 'out-of-stock'
} as const;

export type ProductAddonAvailabilityStatusEnum = typeof ProductAddonAvailabilityStatusEnum[keyof typeof ProductAddonAvailabilityStatusEnum];

/**
 * 
 * @export
 * @interface ProductSearchResult
 */
export interface ProductSearchResult {
    /**
     * 
     * @type {string}
     * @memberof ProductSearchResult
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductSearchResult
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductSearchResult
     */
    'photo': string;
    /**
     * 
     * @type {string}
     * @memberof ProductSearchResult
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProductSearchResult
     */
    'outletId': string;
    /**
     * 
     * @type {number}
     * @memberof ProductSearchResult
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ProductSearchResult
     */
    'availability': ProductSearchResultAvailabilityEnum;
}

export const ProductSearchResultAvailabilityEnum = {
    InStock: 'in-stock',
    OutOfStock: 'out-of-stock'
} as const;

export type ProductSearchResultAvailabilityEnum = typeof ProductSearchResultAvailabilityEnum[keyof typeof ProductSearchResultAvailabilityEnum];

/**
 * 
 * @export
 * @interface RateAndReviewOrderDTO
 */
export interface RateAndReviewOrderDTO {
    /**
     * The customer\'s rating for the order (1-5 scale).
     * @type {number}
     * @memberof RateAndReviewOrderDTO
     */
    'customerRating'?: number;
    /**
     * The customer\'s review or feedback for the order.
     * @type {string}
     * @memberof RateAndReviewOrderDTO
     */
    'customerReview'?: string;
}
/**
 * 
 * @export
 * @interface RiderOrderViewDTO
 */
export interface RiderOrderViewDTO {
    /**
     * Status of the order.
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'status'?: RiderOrderViewDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'expectedDeliveryTimeFormatted': string;
    /**
     * 
     * @type {boolean}
     * @memberof RiderOrderViewDTO
     */
    'isPickup': boolean;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'outletId': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'orderFriendlyId': string;
    /**
     * The name of the vendor
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'vendorName': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'orderType': RiderOrderViewDTOOrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'recipientName': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof RiderOrderViewDTO
     */
    'isGift': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RiderOrderViewDTO
     */
    'isScheduled': boolean;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'scheduledTime': string;
    /**
     * The name of the outlet
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'outletName': string;
    /**
     * Outlet contact phone
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'outletPhone': string;
    /**
     * The logo of the vendor
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'vendorLogo': string;
    /**
     * The address of the outlet
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'outletAddress': string;
    /**
     * The items in the order
     * @type {Array<OrderItem>}
     * @memberof RiderOrderViewDTO
     */
    'items': Array<OrderItem>;
    /**
     * Delivery fee for the order
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'deliveryFee': string;
    /**
     * The total amount for the order
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'total': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'canceledAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'completedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'processingAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'shippedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'deliveredAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'readyForPickupAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'returnedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'arrivedAt': string;
    /**
     * 
     * @type {CustomerAddress}
     * @memberof RiderOrderViewDTO
     */
    'deliveryAddress': CustomerAddress;
    /**
     * 
     * @type {OutletAddress}
     * @memberof RiderOrderViewDTO
     */
    'pickupAddress': OutletAddress;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'recipientPhone': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'customerName': string;
    /**
     * 
     * @type {string}
     * @memberof RiderOrderViewDTO
     */
    'customerPhone': string;
}

export const RiderOrderViewDTOStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Declined: 'declined',
    Processing: 'processing',
    ReadyForPickup: 'ready-for-pickup',
    Shipped: 'shipped',
    OrderArrived: 'order-arrived',
    OrderFulfilled: 'order-fulfilled',
    Returned: 'returned',
    ReturnRequested: 'return-requested',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type RiderOrderViewDTOStatusEnum = typeof RiderOrderViewDTOStatusEnum[keyof typeof RiderOrderViewDTOStatusEnum];
export const RiderOrderViewDTOOrderTypeEnum = {
    Delivery: 'delivery',
    Pickup: 'pickup'
} as const;

export type RiderOrderViewDTOOrderTypeEnum = typeof RiderOrderViewDTOOrderTypeEnum[keyof typeof RiderOrderViewDTOOrderTypeEnum];

/**
 * 
 * @export
 * @interface UpdateCartItemDTO
 */
export interface UpdateCartItemDTO {
    /**
     * The quantity of the product in this cart item.
     * @type {number}
     * @memberof UpdateCartItemDTO
     */
    'quantity': number;
    /**
     * An array of addons associated with this cart item.
     * @type {Array<CartAddon>}
     * @memberof UpdateCartItemDTO
     */
    'addons'?: Array<CartAddon>;
}
/**
 * 
 * @export
 * @interface UserFeedPayload
 */
export interface UserFeedPayload {
    /**
     * An array of outlets near the user\'s location.
     * @type {Array<Outlet>}
     * @memberof UserFeedPayload
     */
    'others': Array<Outlet>;
    /**
     * An array of featured outlets near the user\'s location.
     * @type {Array<Outlet>}
     * @memberof UserFeedPayload
     */
    'featuredNearYou': Array<Outlet>;
    /**
     * An array of recommended outlets near the user\'s location.
     * @type {Array<Outlet>}
     * @memberof UserFeedPayload
     */
    'recommended': Array<Outlet>;
    /**
     * An array of bestsellers outlets near the user\'s location.
     * @type {Array<Outlet>}
     * @memberof UserFeedPayload
     */
    'bestSellers': Array<Outlet>;
    /**
     * An array of promoted outlets near the user\'s location.
     * @type {Array<Outlet>}
     * @memberof UserFeedPayload
     */
    'promoted': Array<Outlet>;
    /**
     * 
     * @type {Array<AdsEntry>}
     * @memberof UserFeedPayload
     */
    'ads': Array<AdsEntry>;
}
/**
 * 
 * @export
 * @interface Zone
 */
export interface Zone {
    /**
     * Unique identifier for the zone, automatically generated by MongoDB.
     * @type {object}
     * @memberof Zone
     */
    'id': object;
    /**
     * 
     * @type {ZoneOverviewMeta}
     * @memberof Zone
     */
    'meta'?: ZoneOverviewMeta;
    /**
     * Name of the zone. This should be a human-readable name that clearly identifies the zone, such as \"Rayfield\" or \"GRA\".
     * @type {string}
     * @memberof Zone
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'handle': string;
    /**
     * Zone alias. This is an optional alternative name or short form for the zone, which can be used for display purposes or user convenience.
     * @type {string}
     * @memberof Zone
     */
    'alias'?: string;
    /**
     * Description of the zone. This provides additional context or details about the zone, such as its boundaries, landmarks, or other relevant information.
     * @type {string}
     * @memberof Zone
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Zone
     */
    'areas': Array<string>;
    /**
     * 
     * @type {ZoneConfig}
     * @memberof Zone
     */
    'config': ZoneConfig;
    /**
     * Geographic coordinates (longitude, latitude) of the zone\'s center point. This is used to define the zone\'s location on a map.
     * @type {Array<number>}
     * @memberof Zone
     */
    'coordinates': Array<number>;
    /**
     * Radius of the zone in meters. This defines the circular area around the center point that is considered part of the zone.
     * @type {number}
     * @memberof Zone
     */
    'radius': number;
    /**
     * 
     * @type {ZoneCentralAddress}
     * @memberof Zone
     */
    'address': ZoneCentralAddress;
    /**
     * State or region code within the country where the zone is located. This should be a valid code for the specified country.
     * @type {string}
     * @memberof Zone
     */
    'stateCode': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'averageDeliveryTimeWithinZoneDesc': string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    'minimumDeliveryFee': string;
    /**
     * 
     * @type {boolean}
     * @memberof Zone
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface ZoneAddressIntentResponse
 */
export interface ZoneAddressIntentResponse {
    /**
     * The formatted address string.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'address': string;
    /**
     * The state code of the address.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'stateCode': string;
    /**
     * The full name of the state.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'state': string;
    /**
     * The country name.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'country': string;
    /**
     * The two-letter ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof ZoneAddressIntentResponse
     */
    'countryCode': string;
    /**
     * 
     * @type {number}
     * @memberof ZoneAddressIntentResponse
     */
    'longitude': number;
    /**
     * 
     * @type {number}
     * @memberof ZoneAddressIntentResponse
     */
    'latitude': number;
}
/**
 * 
 * @export
 * @interface ZoneCentralAddress
 */
export interface ZoneCentralAddress {
    /**
     * Country name (e.g., Nigeria)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'country'?: string;
    /**
     * Country code (e.g., NG)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'countryCode'?: string;
    /**
     * State or region name (e.g., Lagos)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'state'?: string;
    /**
     * State or region code within the country where the zone is located.
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'stateCode'?: string;
    /**
     * Detailed address (e.g., 123 Main St)
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'address'?: string;
    /**
     * Latitude of the address location (decimal format)
     * @type {number}
     * @memberof ZoneCentralAddress
     */
    'latitude'?: number;
    /**
     * Longitude of the address location (decimal format)
     * @type {number}
     * @memberof ZoneCentralAddress
     */
    'longitude'?: number;
    /**
     * The building number or apartment number of the address.
     * @type {string}
     * @memberof ZoneCentralAddress
     */
    'buildingNumber'?: string;
}
/**
 * 
 * @export
 * @interface ZoneConfig
 */
export interface ZoneConfig {
    /**
     * 
     * @type {number}
     * @memberof ZoneConfig
     */
    'averageDeliveryTimeInMins'?: number;
    /**
     * A fixed delivery fee applied to all orders within this zone (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'fixedDeliveryFee'?: number;
    /**
     * A delivery fee applied per kilometer within this zone (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'flatRatePerKm'?: number;
    /**
     * Minimum charge for distance-based delivery (in Naira).
     * @type {number}
     * @memberof ZoneConfig
     */
    'minDistanceDeliveryFee'?: number;
    /**
     * Preferred delivery fee type to use for this zone. Can be either \"flat_rate\" or \"distance_based\".
     * @type {string}
     * @memberof ZoneConfig
     */
    'deliveryFeeType'?: ZoneConfigDeliveryFeeTypeEnum;
    /**
     * Enable price increases during specific time slots
     * @type {boolean}
     * @memberof ZoneConfig
     */
    'enablePriceIncrease'?: boolean;
    /**
     * Time slots with price increases
     * @type {Array<PriceIncreaseTimeSlot>}
     * @memberof ZoneConfig
     */
    'priceIncreaseTimeSlots'?: Array<PriceIncreaseTimeSlot>;
}

export const ZoneConfigDeliveryFeeTypeEnum = {
    FlatRate: 'flat_rate',
    DistanceBased: 'distance_based',
    Free: 'free'
} as const;

export type ZoneConfigDeliveryFeeTypeEnum = typeof ZoneConfigDeliveryFeeTypeEnum[keyof typeof ZoneConfigDeliveryFeeTypeEnum];

/**
 * 
 * @export
 * @interface ZoneOverviewMeta
 */
export interface ZoneOverviewMeta {
    /**
     * 
     * @type {number}
     * @memberof ZoneOverviewMeta
     */
    'totalOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof ZoneOverviewMeta
     */
    'totalOutlets'?: number;
}

/**
 * CartApi - axios parameter creator
 * @export
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an item to the cart
         * @param {AddCartItemDTO} addCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerAddCartItem: async (addCartItemDTO: AddCartItemDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addCartItemDTO' is not null or undefined
            assertParamExists('cartControllerAddCartItem', 'addCartItemDTO', addCartItemDTO)
            const localVarPath = `/v1/marketplace/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCartItemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear the cart for the current customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerClearCart: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/cart/clear-all-cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear the cart items for outlet
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerClearCartForOutlet: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('cartControllerClearCartForOutlet', 'outletId', outletId)
            const localVarPath = `/v1/marketplace/cart/clear-outlet-cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (outletId !== undefined) {
                localVarQueryParameter['outletId'] = outletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all cart items for the current customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartItems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all cart items for the current customer: formatted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartItemsFormatted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/cart/formatted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary formatted outlet cart
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartItemsFormattedForOutlet: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('cartControllerGetCartItemsFormattedForOutlet', 'outletId', outletId)
            const localVarPath = `/v1/marketplace/cart/outlet-formatted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (outletId !== undefined) {
                localVarQueryParameter['outletId'] = outletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an item from the cart
         * @param {string} cartItemId ID of the cart item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerRemoveItemFromCart: async (cartItemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartItemId' is not null or undefined
            assertParamExists('cartControllerRemoveItemFromCart', 'cartItemId', cartItemId)
            const localVarPath = `/v1/marketplace/cart/delete-cart-item/{cartItemId}`
                .replace(`{${"cartItemId"}}`, encodeURIComponent(String(cartItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an item from the cart
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerRemoveItemFromCartByProductId: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('cartControllerRemoveItemFromCartByProductId', 'productId', productId)
            const localVarPath = `/v1/marketplace/cart/delete-cart-item/{productId}/by-product-id`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the quantity or addons of a cart item
         * @param {string} cartItemId ID of the cart item to update
         * @param {UpdateCartItemDTO} updateCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerUpdateCartItem: async (cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartItemId' is not null or undefined
            assertParamExists('cartControllerUpdateCartItem', 'cartItemId', cartItemId)
            // verify required parameter 'updateCartItemDTO' is not null or undefined
            assertParamExists('cartControllerUpdateCartItem', 'updateCartItemDTO', updateCartItemDTO)
            const localVarPath = `/v1/marketplace/cart/{cartItemId}`
                .replace(`{${"cartItemId"}}`, encodeURIComponent(String(cartItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCartItemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add an item to the cart
         * @param {AddCartItemDTO} addCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerAddCartItem(addCartItemDTO: AddCartItemDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerAddCartItem(addCartItemDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerAddCartItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear the cart for the current customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerClearCart(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerClearCart(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerClearCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear the cart items for outlet
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerClearCartForOutlet(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerClearCartForOutlet(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerClearCartForOutlet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all cart items for the current customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerGetCartItems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CartItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerGetCartItems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerGetCartItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all cart items for the current customer: formatted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerGetCartItemsFormatted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FormattedCart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerGetCartItemsFormatted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerGetCartItemsFormatted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary formatted outlet cart
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerGetCartItemsFormattedForOutlet(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormattedCart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerGetCartItemsFormattedForOutlet(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerGetCartItemsFormattedForOutlet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an item from the cart
         * @param {string} cartItemId ID of the cart item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerRemoveItemFromCart(cartItemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerRemoveItemFromCart(cartItemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerRemoveItemFromCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an item from the cart
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerRemoveItemFromCartByProductId(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerRemoveItemFromCartByProductId(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerRemoveItemFromCartByProductId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the quantity or addons of a cart item
         * @param {string} cartItemId ID of the cart item to update
         * @param {UpdateCartItemDTO} updateCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartControllerUpdateCartItem(cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CartItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartControllerUpdateCartItem(cartItemId, updateCartItemDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.cartControllerUpdateCartItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * 
         * @summary Add an item to the cart
         * @param {AddCartItemDTO} addCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerAddCartItem(addCartItemDTO: AddCartItemDTO, options?: RawAxiosRequestConfig): AxiosPromise<CartItem> {
            return localVarFp.cartControllerAddCartItem(addCartItemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear the cart for the current customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerClearCart(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cartControllerClearCart(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear the cart items for outlet
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerClearCartForOutlet(outletId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cartControllerClearCartForOutlet(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all cart items for the current customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartItems(options?: RawAxiosRequestConfig): AxiosPromise<Array<CartItem>> {
            return localVarFp.cartControllerGetCartItems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all cart items for the current customer: formatted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartItemsFormatted(options?: RawAxiosRequestConfig): AxiosPromise<Array<FormattedCart>> {
            return localVarFp.cartControllerGetCartItemsFormatted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary formatted outlet cart
         * @param {string} outletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerGetCartItemsFormattedForOutlet(outletId: string, options?: RawAxiosRequestConfig): AxiosPromise<FormattedCart> {
            return localVarFp.cartControllerGetCartItemsFormattedForOutlet(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an item from the cart
         * @param {string} cartItemId ID of the cart item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerRemoveItemFromCart(cartItemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cartControllerRemoveItemFromCart(cartItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an item from the cart
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerRemoveItemFromCartByProductId(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cartControllerRemoveItemFromCartByProductId(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the quantity or addons of a cart item
         * @param {string} cartItemId ID of the cart item to update
         * @param {UpdateCartItemDTO} updateCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartControllerUpdateCartItem(cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options?: RawAxiosRequestConfig): AxiosPromise<CartItem> {
            return localVarFp.cartControllerUpdateCartItem(cartItemId, updateCartItemDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * 
     * @summary Add an item to the cart
     * @param {AddCartItemDTO} addCartItemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerAddCartItem(addCartItemDTO: AddCartItemDTO, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerAddCartItem(addCartItemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear the cart for the current customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerClearCart(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerClearCart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear the cart items for outlet
     * @param {string} outletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerClearCartForOutlet(outletId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerClearCartForOutlet(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all cart items for the current customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerGetCartItems(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerGetCartItems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all cart items for the current customer: formatted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerGetCartItemsFormatted(options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerGetCartItemsFormatted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary formatted outlet cart
     * @param {string} outletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerGetCartItemsFormattedForOutlet(outletId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerGetCartItemsFormattedForOutlet(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an item from the cart
     * @param {string} cartItemId ID of the cart item to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerRemoveItemFromCart(cartItemId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerRemoveItemFromCart(cartItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an item from the cart
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerRemoveItemFromCartByProductId(productId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerRemoveItemFromCartByProductId(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the quantity or addons of a cart item
     * @param {string} cartItemId ID of the cart item to update
     * @param {UpdateCartItemDTO} updateCartItemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartControllerUpdateCartItem(cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).cartControllerUpdateCartItem(cartItemId, updateCartItemDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExploreApi - axios parameter creator
 * @export
 */
export const ExploreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get market types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerGetMarketTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/explore/market-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get outlets near the authenticated user\'s active address
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerGetOutletsNearUser: async (zoneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('exploreControllerGetOutletsNearUser', 'zoneId', zoneId)
            const localVarPath = `/v1/marketplace/explore/outlets-near-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (zoneId !== undefined) {
                localVarQueryParameter['zoneId'] = zoneId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get top categories
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerGetTopCategories: async (zoneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('exploreControllerGetTopCategories', 'zoneId', zoneId)
            const localVarPath = `/v1/marketplace/explore/top-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (zoneId !== undefined) {
                localVarQueryParameter['zoneId'] = zoneId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for products/outlets
         * @param {string} query The search query string to match against product names or descriptions.
         * @param {string} zoneId 
         * @param {string} [primaryMarketSegment] Primary market segment that the outlet serves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerSearch: async (query: string, zoneId: string, primaryMarketSegment?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('exploreControllerSearch', 'query', query)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('exploreControllerSearch', 'zoneId', zoneId)
            const localVarPath = `/v1/marketplace/explore/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (zoneId !== undefined) {
                localVarQueryParameter['zoneId'] = zoneId;
            }

            if (primaryMarketSegment !== undefined) {
                localVarQueryParameter['primaryMarketSegment'] = primaryMarketSegment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExploreApi - functional programming interface
 * @export
 */
export const ExploreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExploreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get market types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploreControllerGetMarketTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalTaxonomy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploreControllerGetMarketTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExploreApi.exploreControllerGetMarketTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get outlets near the authenticated user\'s active address
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploreControllerGetOutletsNearUser(zoneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outlet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploreControllerGetOutletsNearUser(zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExploreApi.exploreControllerGetOutletsNearUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get top categories
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploreControllerGetTopCategories(zoneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalTaxonomy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploreControllerGetTopCategories(zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExploreApi.exploreControllerGetTopCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for products/outlets
         * @param {string} query The search query string to match against product names or descriptions.
         * @param {string} zoneId 
         * @param {string} [primaryMarketSegment] Primary market segment that the outlet serves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploreControllerSearch(query: string, zoneId: string, primaryMarketSegment?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupedSearchProductResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploreControllerSearch(query, zoneId, primaryMarketSegment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExploreApi.exploreControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExploreApi - factory interface
 * @export
 */
export const ExploreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExploreApiFp(configuration)
    return {
        /**
         * 
         * @summary Get market types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerGetMarketTypes(options?: RawAxiosRequestConfig): AxiosPromise<GlobalTaxonomy> {
            return localVarFp.exploreControllerGetMarketTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get outlets near the authenticated user\'s active address
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerGetOutletsNearUser(zoneId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Outlet>> {
            return localVarFp.exploreControllerGetOutletsNearUser(zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get top categories
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerGetTopCategories(zoneId: string, options?: RawAxiosRequestConfig): AxiosPromise<GlobalTaxonomy> {
            return localVarFp.exploreControllerGetTopCategories(zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for products/outlets
         * @param {string} query The search query string to match against product names or descriptions.
         * @param {string} zoneId 
         * @param {string} [primaryMarketSegment] Primary market segment that the outlet serves.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreControllerSearch(query: string, zoneId: string, primaryMarketSegment?: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupedSearchProductResponseDto> {
            return localVarFp.exploreControllerSearch(query, zoneId, primaryMarketSegment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExploreApi - object-oriented interface
 * @export
 * @class ExploreApi
 * @extends {BaseAPI}
 */
export class ExploreApi extends BaseAPI {
    /**
     * 
     * @summary Get market types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreApi
     */
    public exploreControllerGetMarketTypes(options?: RawAxiosRequestConfig) {
        return ExploreApiFp(this.configuration).exploreControllerGetMarketTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get outlets near the authenticated user\'s active address
     * @param {string} zoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreApi
     */
    public exploreControllerGetOutletsNearUser(zoneId: string, options?: RawAxiosRequestConfig) {
        return ExploreApiFp(this.configuration).exploreControllerGetOutletsNearUser(zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get top categories
     * @param {string} zoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreApi
     */
    public exploreControllerGetTopCategories(zoneId: string, options?: RawAxiosRequestConfig) {
        return ExploreApiFp(this.configuration).exploreControllerGetTopCategories(zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for products/outlets
     * @param {string} query The search query string to match against product names or descriptions.
     * @param {string} zoneId 
     * @param {string} [primaryMarketSegment] Primary market segment that the outlet serves.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploreApi
     */
    public exploreControllerSearch(query: string, zoneId: string, primaryMarketSegment?: string, options?: RawAxiosRequestConfig) {
        return ExploreApiFp(this.configuration).exploreControllerSearch(query, zoneId, primaryMarketSegment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedApi - axios parameter creator
 * @export
 */
export const FeedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get personalized feed for the current user
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetUserFeed: async (zoneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('feedControllerGetUserFeed', 'zoneId', zoneId)
            const localVarPath = `/v1/marketplace/feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (zoneId !== undefined) {
                localVarQueryParameter['zoneId'] = zoneId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get personalized feed for the current user
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedControllerGetUserFeed(zoneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFeedPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedControllerGetUserFeed(zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedApi.feedControllerGetUserFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedApiFp(configuration)
    return {
        /**
         * 
         * @summary Get personalized feed for the current user
         * @param {string} zoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedControllerGetUserFeed(zoneId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserFeedPayload> {
            return localVarFp.feedControllerGetUserFeed(zoneId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
    /**
     * 
     * @summary Get personalized feed for the current user
     * @param {string} zoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public feedControllerGetUserFeed(zoneId: string, options?: RawAxiosRequestConfig) {
        return FeedApiFp(this.configuration).feedControllerGetUserFeed(zoneId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GuestApi - axios parameter creator
 * @export
 */
export const GuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get guest zone ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestControllerGetGuestZoneId: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/guest/guest-zone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get personalized feed for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestControllerGetUserFeed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/guest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestApi - functional programming interface
 * @export
 */
export const GuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get guest zone ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestControllerGetGuestZoneId(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestControllerGetGuestZoneId(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.guestControllerGetGuestZoneId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get personalized feed for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guestControllerGetUserFeed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFeedPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guestControllerGetUserFeed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.guestControllerGetUserFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuestApi - factory interface
 * @export
 */
export const GuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestApiFp(configuration)
    return {
        /**
         * 
         * @summary Get guest zone ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestControllerGetGuestZoneId(options?: RawAxiosRequestConfig): AxiosPromise<Zone> {
            return localVarFp.guestControllerGetGuestZoneId(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get personalized feed for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guestControllerGetUserFeed(options?: RawAxiosRequestConfig): AxiosPromise<UserFeedPayload> {
            return localVarFp.guestControllerGetUserFeed(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestApi - object-oriented interface
 * @export
 * @class GuestApi
 * @extends {BaseAPI}
 */
export class GuestApi extends BaseAPI {
    /**
     * 
     * @summary Get guest zone ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public guestControllerGetGuestZoneId(options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).guestControllerGetGuestZoneId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get personalized feed for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public guestControllerGetUserFeed(options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).guestControllerGetUserFeed(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarketplaceApi - axios parameter creator
 * @export
 */
export const MarketplaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get outlet details for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetOutletDetails: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('marketplaceControllerGetOutletDetails', 'outletId', outletId)
            const localVarPath = `/v1/marketplace/marketplace/outlets/{outletId}`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get outlet details for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetOutletDetailsPlain: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('marketplaceControllerGetOutletDetailsPlain', 'outletId', outletId)
            const localVarPath = `/v1/marketplace/marketplace/outlets/{outletId}/plain`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get outlet inventory and categories for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetOutletInventory: async (outletId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outletId' is not null or undefined
            assertParamExists('marketplaceControllerGetOutletInventory', 'outletId', outletId)
            const localVarPath = `/v1/marketplace/marketplace/outlets/{outletId}/inventory`
                .replace(`{${"outletId"}}`, encodeURIComponent(String(outletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product details for the marketplace
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetProductDetails: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerGetProductDetails', 'productId', productId)
            const localVarPath = `/v1/marketplace/marketplace/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent: async (placeId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'placeId', placeId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'provider', provider)
            const localVarPath = `/v1/marketplace/zone-utils/address-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (placeId !== undefined) {
                localVarQueryParameter['placeId'] = placeId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations: async (longitude: number, latitude: number, radius: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'latitude', latitude)
            // verify required parameter 'radius' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'radius', radius)
            const localVarPath = `/v1/marketplace/zone-utils/nearby-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('zoneUtilsControllerGetZoneById', 'id', id)
            const localVarPath = `/v1/marketplace/zone-utils/get-zone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketplaceApi - functional programming interface
 * @export
 */
export const MarketplaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketplaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get outlet details for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerGetOutletDetails(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutletMarketplaceDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerGetOutletDetails(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerGetOutletDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get outlet details for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerGetOutletDetailsPlain(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerGetOutletDetailsPlain(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerGetOutletDetailsPlain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get outlet inventory and categories for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerGetOutletInventory(outletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketplaceOutletInventory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerGetOutletInventory(outletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerGetOutletInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get product details for the marketplace
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerGetProductDetails(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketplaceProductListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerGetProductDetails(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerGetProductDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneAddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerAddAddressIntent(placeId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.zoneUtilsControllerAddAddressIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Zone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.zoneUtilsControllerFindNearbyLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerGetZoneById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.zoneUtilsControllerGetZoneById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketplaceApi - factory interface
 * @export
 */
export const MarketplaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketplaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Get outlet details for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetOutletDetails(outletId: string, options?: RawAxiosRequestConfig): AxiosPromise<OutletMarketplaceDetail> {
            return localVarFp.marketplaceControllerGetOutletDetails(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get outlet details for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetOutletDetailsPlain(outletId: string, options?: RawAxiosRequestConfig): AxiosPromise<Outlet> {
            return localVarFp.marketplaceControllerGetOutletDetailsPlain(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get outlet inventory and categories for the marketplace
         * @param {string} outletId ID of the outlet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetOutletInventory(outletId: string, options?: RawAxiosRequestConfig): AxiosPromise<MarketplaceOutletInventory> {
            return localVarFp.marketplaceControllerGetOutletInventory(outletId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product details for the marketplace
         * @param {string} productId ID of the product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerGetProductDetails(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<MarketplaceProductListing> {
            return localVarFp.marketplaceControllerGetProductDetails(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<ZoneAddressIntentResponse> {
            return localVarFp.zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Zone>> {
            return localVarFp.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Zone> {
            return localVarFp.zoneUtilsControllerGetZoneById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketplaceApi - object-oriented interface
 * @export
 * @class MarketplaceApi
 * @extends {BaseAPI}
 */
export class MarketplaceApi extends BaseAPI {
    /**
     * 
     * @summary Get outlet details for the marketplace
     * @param {string} outletId ID of the outlet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerGetOutletDetails(outletId: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerGetOutletDetails(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get outlet details for the marketplace
     * @param {string} outletId ID of the outlet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerGetOutletDetailsPlain(outletId: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerGetOutletDetailsPlain(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get outlet inventory and categories for the marketplace
     * @param {string} outletId ID of the outlet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerGetOutletInventory(outletId: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerGetOutletInventory(outletId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product details for the marketplace
     * @param {string} productId ID of the product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerGetProductDetails(productId: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerGetProductDetails(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} placeId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} longitude 
     * @param {number} latitude 
     * @param {number} radius 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).zoneUtilsControllerGetZoneById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyOrdersApi - axios parameter creator
 * @export
 */
export const MyOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel an order
         * @param {string} orderId ID of the order to cancel
         * @param {CancelOrderDTO} cancelOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerCancelOrder: async (orderId: string, cancelOrderDTO: CancelOrderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('customerOrderControllerCancelOrder', 'orderId', orderId)
            // verify required parameter 'cancelOrderDTO' is not null or undefined
            assertParamExists('customerOrderControllerCancelOrder', 'cancelOrderDTO', cancelOrderDTO)
            const localVarPath = `/v1/marketplace/customer/orders/{orderId}/cancel`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an order intent
         * @param {NewOrderIntentDTO} newOrderIntentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerCreateOrderIntent: async (newOrderIntentDTO: NewOrderIntentDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newOrderIntentDTO' is not null or undefined
            assertParamExists('customerOrderControllerCreateOrderIntent', 'newOrderIntentDTO', newOrderIntentDTO)
            const localVarPath = `/v1/marketplace/customer/orders/intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newOrderIntentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Completed orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetCustomerCompletedOrders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/customer/orders/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get paginated orders for the current customer
         * @param {Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>} [status] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetCustomerOrders: async (status?: Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/customer/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ongoing orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetCustomerOrdersOnGoing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/customer/orders/ongoing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place a new order
         * @param {PlaceOrderDTO} placeOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPlaceOrder: async (placeOrderDTO: PlaceOrderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeOrderDTO' is not null or undefined
            assertParamExists('customerOrderControllerPlaceOrder', 'placeOrderDTO', placeOrderDTO)
            const localVarPath = `/v1/marketplace/customer/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeOrderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rate and review an order
         * @param {string} orderId ID of the order to rate and review
         * @param {RateAndReviewOrderDTO} rateAndReviewOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerRateAndReviewOrder: async (orderId: string, rateAndReviewOrderDTO: RateAndReviewOrderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('customerOrderControllerRateAndReviewOrder', 'orderId', orderId)
            // verify required parameter 'rateAndReviewOrderDTO' is not null or undefined
            assertParamExists('customerOrderControllerRateAndReviewOrder', 'rateAndReviewOrderDTO', rateAndReviewOrderDTO)
            const localVarPath = `/v1/marketplace/customer/orders/{orderId}/rate-and-review`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateAndReviewOrderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a new order confirmation PIN
         * @param {string} orderId ID of the order to request a PIN for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerRequestNewPin: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('customerOrderControllerRequestNewPin', 'orderId', orderId)
            const localVarPath = `/v1/marketplace/customer/orders/{orderId}/request-pin`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyOrdersApi - functional programming interface
 * @export
 */
export const MyOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel an order
         * @param {string} orderId ID of the order to cancel
         * @param {CancelOrderDTO} cancelOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerCancelOrder(orderId: string, cancelOrderDTO: CancelOrderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerCancelOrder(orderId, cancelOrderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerCancelOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an order intent
         * @param {NewOrderIntentDTO} newOrderIntentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerCreateOrderIntent(newOrderIntentDTO: NewOrderIntentDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderPreview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerCreateOrderIntent(newOrderIntentDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerCreateOrderIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Completed orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerGetCustomerCompletedOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerGetCustomerCompletedOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerGetCustomerCompletedOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get paginated orders for the current customer
         * @param {Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>} [status] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerGetCustomerOrders(status?: Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerGetCustomerOrders(status, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerGetCustomerOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Ongoing orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerGetCustomerOrdersOnGoing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerGetCustomerOrdersOnGoing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerGetCustomerOrdersOnGoing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Place a new order
         * @param {PlaceOrderDTO} placeOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerPlaceOrder(placeOrderDTO: PlaceOrderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerPlaceOrder(placeOrderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerPlaceOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rate and review an order
         * @param {string} orderId ID of the order to rate and review
         * @param {RateAndReviewOrderDTO} rateAndReviewOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerRateAndReviewOrder(orderId: string, rateAndReviewOrderDTO: RateAndReviewOrderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerRateAndReviewOrder(orderId, rateAndReviewOrderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerRateAndReviewOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request a new order confirmation PIN
         * @param {string} orderId ID of the order to request a PIN for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerRequestNewPin(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerRequestNewPin(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyOrdersApi.customerOrderControllerRequestNewPin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyOrdersApi - factory interface
 * @export
 */
export const MyOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyOrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel an order
         * @param {string} orderId ID of the order to cancel
         * @param {CancelOrderDTO} cancelOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerCancelOrder(orderId: string, cancelOrderDTO: CancelOrderDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerOrderControllerCancelOrder(orderId, cancelOrderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an order intent
         * @param {NewOrderIntentDTO} newOrderIntentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerCreateOrderIntent(newOrderIntentDTO: NewOrderIntentDTO, options?: RawAxiosRequestConfig): AxiosPromise<OrderPreview> {
            return localVarFp.customerOrderControllerCreateOrderIntent(newOrderIntentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Completed orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetCustomerCompletedOrders(options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.customerOrderControllerGetCustomerCompletedOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get paginated orders for the current customer
         * @param {Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>} [status] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetCustomerOrders(status?: Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedOrderResponseDto> {
            return localVarFp.customerOrderControllerGetCustomerOrders(status, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Ongoing orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerGetCustomerOrdersOnGoing(options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.customerOrderControllerGetCustomerOrdersOnGoing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place a new order
         * @param {PlaceOrderDTO} placeOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPlaceOrder(placeOrderDTO: PlaceOrderDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerOrderControllerPlaceOrder(placeOrderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rate and review an order
         * @param {string} orderId ID of the order to rate and review
         * @param {RateAndReviewOrderDTO} rateAndReviewOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerRateAndReviewOrder(orderId: string, rateAndReviewOrderDTO: RateAndReviewOrderDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerOrderControllerRateAndReviewOrder(orderId, rateAndReviewOrderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a new order confirmation PIN
         * @param {string} orderId ID of the order to request a PIN for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerRequestNewPin(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerOrderControllerRequestNewPin(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MyOrdersApi - object-oriented interface
 * @export
 * @class MyOrdersApi
 * @extends {BaseAPI}
 */
export class MyOrdersApi extends BaseAPI {
    /**
     * 
     * @summary Cancel an order
     * @param {string} orderId ID of the order to cancel
     * @param {CancelOrderDTO} cancelOrderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerCancelOrder(orderId: string, cancelOrderDTO: CancelOrderDTO, options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerCancelOrder(orderId, cancelOrderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an order intent
     * @param {NewOrderIntentDTO} newOrderIntentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerCreateOrderIntent(newOrderIntentDTO: NewOrderIntentDTO, options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerCreateOrderIntent(newOrderIntentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Completed orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerGetCustomerCompletedOrders(options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerGetCustomerCompletedOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get paginated orders for the current customer
     * @param {Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>} [status] 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerGetCustomerOrders(status?: Array<CustomerOrderControllerGetCustomerOrdersStatusEnum>, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerGetCustomerOrders(status, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Ongoing orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerGetCustomerOrdersOnGoing(options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerGetCustomerOrdersOnGoing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place a new order
     * @param {PlaceOrderDTO} placeOrderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerPlaceOrder(placeOrderDTO: PlaceOrderDTO, options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerPlaceOrder(placeOrderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rate and review an order
     * @param {string} orderId ID of the order to rate and review
     * @param {RateAndReviewOrderDTO} rateAndReviewOrderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerRateAndReviewOrder(orderId: string, rateAndReviewOrderDTO: RateAndReviewOrderDTO, options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerRateAndReviewOrder(orderId, rateAndReviewOrderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a new order confirmation PIN
     * @param {string} orderId ID of the order to request a PIN for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyOrdersApi
     */
    public customerOrderControllerRequestNewPin(orderId: string, options?: RawAxiosRequestConfig) {
        return MyOrdersApiFp(this.configuration).customerOrderControllerRequestNewPin(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CustomerOrderControllerGetCustomerOrdersStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Declined: 'declined',
    Processing: 'processing',
    ReadyForPickup: 'ready-for-pickup',
    Shipped: 'shipped',
    OrderArrived: 'order-arrived',
    OrderFulfilled: 'order-fulfilled',
    Returned: 'returned',
    ReturnRequested: 'return-requested',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;
export type CustomerOrderControllerGetCustomerOrdersStatusEnum = typeof CustomerOrderControllerGetCustomerOrdersStatusEnum[keyof typeof CustomerOrderControllerGetCustomerOrdersStatusEnum];


/**
 * OrderPaymentApi - axios parameter creator
 * @export
 */
export const OrderPaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Pay for order using Paystack
         * @param {string} orderId ID of the order to pay for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPayForOrderWithPaystack: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('customerOrderControllerPayForOrderWithPaystack', 'orderId', orderId)
            const localVarPath = `/v1/marketplace/customer/orders/{orderId}/paystack-pay`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pay for order using a new card via Paystack
         * @param {string} orderId ID of the order to pay for
         * @param {PaywithCardDto} paywithCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPayForOrderWithPaystackCard: async (orderId: string, paywithCardDto: PaywithCardDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('customerOrderControllerPayForOrderWithPaystackCard', 'orderId', orderId)
            // verify required parameter 'paywithCardDto' is not null or undefined
            assertParamExists('customerOrderControllerPayForOrderWithPaystackCard', 'paywithCardDto', paywithCardDto)
            const localVarPath = `/v1/marketplace/customer/orders/{orderId}/paystack-card-pay`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paywithCardDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pay for an order using the customer\'s wallet balance
         * @param {string} orderId ID of the order to pay for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPayWithWallet: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('customerOrderControllerPayWithWallet', 'orderId', orderId)
            const localVarPath = `/v1/marketplace/customer/orders/{orderId}/pay-with-wallet`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderPaymentApi - functional programming interface
 * @export
 */
export const OrderPaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderPaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Pay for order using Paystack
         * @param {string} orderId ID of the order to pay for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerPayForOrderWithPaystack(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaystackTransactionIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerPayForOrderWithPaystack(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderPaymentApi.customerOrderControllerPayForOrderWithPaystack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Pay for order using a new card via Paystack
         * @param {string} orderId ID of the order to pay for
         * @param {PaywithCardDto} paywithCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerPayForOrderWithPaystackCard(orderId: string, paywithCardDto: PaywithCardDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerPayForOrderWithPaystackCard(orderId, paywithCardDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderPaymentApi.customerOrderControllerPayForOrderWithPaystackCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Pay for an order using the customer\'s wallet balance
         * @param {string} orderId ID of the order to pay for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerOrderControllerPayWithWallet(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerOrderControllerPayWithWallet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderPaymentApi.customerOrderControllerPayWithWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderPaymentApi - factory interface
 * @export
 */
export const OrderPaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderPaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Pay for order using Paystack
         * @param {string} orderId ID of the order to pay for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPayForOrderWithPaystack(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaystackTransactionIntent> {
            return localVarFp.customerOrderControllerPayForOrderWithPaystack(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pay for order using a new card via Paystack
         * @param {string} orderId ID of the order to pay for
         * @param {PaywithCardDto} paywithCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPayForOrderWithPaystackCard(orderId: string, paywithCardDto: PaywithCardDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerOrderControllerPayForOrderWithPaystackCard(orderId, paywithCardDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pay for an order using the customer\'s wallet balance
         * @param {string} orderId ID of the order to pay for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerOrderControllerPayWithWallet(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.customerOrderControllerPayWithWallet(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderPaymentApi - object-oriented interface
 * @export
 * @class OrderPaymentApi
 * @extends {BaseAPI}
 */
export class OrderPaymentApi extends BaseAPI {
    /**
     * 
     * @summary Pay for order using Paystack
     * @param {string} orderId ID of the order to pay for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderPaymentApi
     */
    public customerOrderControllerPayForOrderWithPaystack(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderPaymentApiFp(this.configuration).customerOrderControllerPayForOrderWithPaystack(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pay for order using a new card via Paystack
     * @param {string} orderId ID of the order to pay for
     * @param {PaywithCardDto} paywithCardDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderPaymentApi
     */
    public customerOrderControllerPayForOrderWithPaystackCard(orderId: string, paywithCardDto: PaywithCardDto, options?: RawAxiosRequestConfig) {
        return OrderPaymentApiFp(this.configuration).customerOrderControllerPayForOrderWithPaystackCard(orderId, paywithCardDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pay for an order using the customer\'s wallet balance
     * @param {string} orderId ID of the order to pay for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderPaymentApi
     */
    public customerOrderControllerPayWithWallet(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderPaymentApiFp(this.configuration).customerOrderControllerPayWithWallet(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetOCustomerOrderDetails: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderControllerGetOCustomerOrderDetails', 'orderId', orderId)
            const localVarPath = `/v1/marketplace/orders/{orderId}/customer-order-details`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetOrderById: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderControllerGetOrderById', 'orderId', orderId)
            const localVarPath = `/v1/marketplace/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetRiderOrderDetails: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderControllerGetRiderOrderDetails', 'orderId', orderId)
            const localVarPath = `/v1/marketplace/orders/{orderId}/rider-order-details`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetVendorOrderDetails: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderControllerGetVendorOrderDetails', 'orderId', orderId)
            const localVarPath = `/v1/marketplace/orders/{orderId}/vendor-order-details`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGetOCustomerOrderDetails(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerOrderViewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGetOCustomerOrderDetails(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerGetOCustomerOrderDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGetOrderById(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGetOrderById(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerGetOrderById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGetRiderOrderDetails(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RiderOrderViewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGetRiderOrderDetails(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerGetRiderOrderDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGetVendorOrderDetails(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RiderOrderViewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGetVendorOrderDetails(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerGetVendorOrderDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetOCustomerOrderDetails(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerOrderViewDTO> {
            return localVarFp.orderControllerGetOCustomerOrderDetails(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetOrderById(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.orderControllerGetOrderById(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetRiderOrderDetails(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<RiderOrderViewDTO> {
            return localVarFp.orderControllerGetRiderOrderDetails(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get order details by ID
         * @param {string} orderId ID of the order to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetVendorOrderDetails(orderId: string, options?: RawAxiosRequestConfig): AxiosPromise<RiderOrderViewDTO> {
            return localVarFp.orderControllerGetVendorOrderDetails(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @summary Get order details by ID
     * @param {string} orderId ID of the order to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerGetOCustomerOrderDetails(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerGetOCustomerOrderDetails(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order details by ID
     * @param {string} orderId ID of the order to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerGetOrderById(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerGetOrderById(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order details by ID
     * @param {string} orderId ID of the order to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerGetRiderOrderDetails(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerGetRiderOrderDetails(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get order details by ID
     * @param {string} orderId ID of the order to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerGetVendorOrderDetails(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerGetVendorOrderDetails(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ZoneHelpersApi - axios parameter creator
 * @export
 */
export const ZoneHelpersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent: async (placeId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'placeId', placeId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('zoneUtilsControllerAddAddressIntent', 'provider', provider)
            const localVarPath = `/v1/marketplace/zone-utils/address-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (placeId !== undefined) {
                localVarQueryParameter['placeId'] = placeId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations: async (longitude: number, latitude: number, radius: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'longitude', longitude)
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'latitude', latitude)
            // verify required parameter 'radius' is not null or undefined
            assertParamExists('zoneUtilsControllerFindNearbyLocations', 'radius', radius)
            const localVarPath = `/v1/marketplace/zone-utils/nearby-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('zoneUtilsControllerGetZoneById', 'id', id)
            const localVarPath = `/v1/marketplace/zone-utils/get-zone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneHelpersApi - functional programming interface
 * @export
 */
export const ZoneHelpersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ZoneHelpersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneAddressIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerAddAddressIntent(placeId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneHelpersApi.zoneUtilsControllerAddAddressIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Zone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneHelpersApi.zoneUtilsControllerFindNearbyLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneUtilsControllerGetZoneById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneHelpersApi.zoneUtilsControllerGetZoneById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ZoneHelpersApi - factory interface
 * @export
 */
export const ZoneHelpersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ZoneHelpersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} placeId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig): AxiosPromise<ZoneAddressIntentResponse> {
            return localVarFp.zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} longitude 
         * @param {number} latitude 
         * @param {number} radius 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Zone>> {
            return localVarFp.zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Zone> {
            return localVarFp.zoneUtilsControllerGetZoneById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneHelpersApi - object-oriented interface
 * @export
 * @class ZoneHelpersApi
 * @extends {BaseAPI}
 */
export class ZoneHelpersApi extends BaseAPI {
    /**
     * 
     * @param {string} placeId 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneHelpersApi
     */
    public zoneUtilsControllerAddAddressIntent(placeId: string, provider: string, options?: RawAxiosRequestConfig) {
        return ZoneHelpersApiFp(this.configuration).zoneUtilsControllerAddAddressIntent(placeId, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} longitude 
     * @param {number} latitude 
     * @param {number} radius 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneHelpersApi
     */
    public zoneUtilsControllerFindNearbyLocations(longitude: number, latitude: number, radius: number, options?: RawAxiosRequestConfig) {
        return ZoneHelpersApiFp(this.configuration).zoneUtilsControllerFindNearbyLocations(longitude, latitude, radius, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneHelpersApi
     */
    public zoneUtilsControllerGetZoneById(id: string, options?: RawAxiosRequestConfig) {
        return ZoneHelpersApiFp(this.configuration).zoneUtilsControllerGetZoneById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



